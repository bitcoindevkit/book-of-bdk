{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"","text":"<p>The Bitcoin Development Kit (BDK) project provides well engineered and reviewed components for building bitcoin-based applications. This book hosts a collections of pages to get you started on all things BDK!</p>","path":[""],"tags":[]},{"location":"cookbook/starter-example/","level":1,"title":"Simple Starter Example","text":"<p>So you want to build a bitcoin wallet using BDK. Great! Here is the rough outline of what you need to do just that. A standard, simple example of a bitcoin wallet in BDK-land would require 3 core pillars:</p> <p> </p> <ol> <li>The <code>bdk_wallet</code> library, which will provide two core types: the <code>Wallet</code> and the <code>TxBuilder</code>. This library will handle all the domain logic related to keeping track of which UTXOs you own, what your total balance is, creating and signing transactions, etc.</li> <li>A blockchain client. Your wallet will need to keep track of blockchain data, like new transactions that have been added to the blockchain that impact your wallet, requesting these transactions from a Bitcoin Core node, an Electrum or Esplora server, etc.</li> <li>A persistence mechanism for saving wallet data between sessions (note that this is not actually required). Things like which addresses the wallet has revealed and what is the state of the blockchain on its last sync are things that are kept in persistence and can be loaded on startup.</li> </ol>","path":["Cookbook","Simple Starter Example"],"tags":[]},{"location":"cookbook/starter-example/#diving-in","level":2,"title":"Diving in!","text":"<p>This page provides a starter example showcasing how BDK can be used to create, sync, and manage a wallet using an Esplora client as a blockchain data source. Familiarity with this example will help you work through the more advanced pages in this section.</p> <p>You can find working code examples of this example in three programming languages: Rust, Swift, and Kotlin. (Note: some additional language bindings are available for BDK, see 3rd Party Bindings).</p> <p>Tip</p> <p>To complete this example from top to bottom, you'll need to create new descriptors and replace the ones provided. Once you do so, you'll run the example twice; on first run the wallet will not have any balance and will exit with an address to send funds to. Once that's done, you can run the example again and the wallet will be able to perform the later steps, namely creating and broadcasting a new transaction.</p>","path":["Cookbook","Simple Starter Example"],"tags":[]},{"location":"cookbook/starter-example/#create-a-new-project","level":2,"title":"Create a new project","text":"<pre><code>cargo init starter-example\ncd starter-example\n</code></pre>","path":["Cookbook","Simple Starter Example"],"tags":[]},{"location":"cookbook/starter-example/#add-required-dependencies","level":2,"title":"Add required dependencies","text":"Cargo.toml<pre><code>[package]\nname = \"starter-example\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nbdk_wallet = { version = \"2.2.0\", features = [\"rusqlite\"] }\nbdk_esplora = { version = \"0.22.1\", features = [\"blocking\"] }\n</code></pre>","path":["Cookbook","Simple Starter Example"],"tags":[]},{"location":"cookbook/starter-example/#use-descriptors","level":2,"title":"Use descriptors","text":"<p>To create a wallet using BDK, we need some descriptors for our wallet. This example uses public descriptors (meaning they cannot be used to sign transactions) on Signet. Step 7 and below will fail unless you replace those public descriptors with private ones of your own and fund them using Signet coins through a faucet. Refer to the Creating Descriptors page for information on how to generate your own private descriptors.</p> <p>Warning</p> <p>Note that if you replace the descriptors after running the example using the provided ones, you must delete or rename the database file or will get an error on wallet load.</p> <pre><code>let descriptor: &amp;str = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\";\nlet change_descriptor: &amp;str = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\";\n</code></pre> <p>These are taproot descriptors (<code>tr()</code>) using public keys on Signet (<code>tpub</code>) as described in BIP86. The first descriptor is an HD wallet with a path for generating addresses to give out externally for payments. The second one is used by the wallet to generate addresses to pay ourselves change when sending payments (remember that UTXOs must be spent in full, so you often need to make change).</p>","path":["Cookbook","Simple Starter Example"],"tags":[]},{"location":"cookbook/starter-example/#create-or-load-a-wallet","level":2,"title":"Create or load a wallet","text":"<p>Next let's load up our wallet.</p> starter-example/src/main.rs<pre><code>// Initiate the connection to the database\nlet mut conn = Connection::open(DB_PATH).expect(\"Can't open database\");\n\n// Create the wallet\nlet wallet_opt = Wallet::load()\n    .descriptor(KeychainKind::External, Some(descriptor))\n    .descriptor(KeychainKind::Internal, Some(change_descriptor))\n    // .extract_keys() // uncomment this line when using private descriptors\n    .check_network(Network::Signet)\n    .load_wallet(&amp;mut conn)\n    .unwrap();\n\nlet mut wallet = if let Some(loaded_wallet) = wallet_opt {\n    loaded_wallet\n} else {\n    Wallet::create(descriptor, change_descriptor)\n        .network(Network::Signet)\n        .create_wallet(&amp;mut conn)\n        .unwrap()\n};\n</code></pre>","path":["Cookbook","Simple Starter Example"],"tags":[]},{"location":"cookbook/starter-example/#sync-the-wallet","level":2,"title":"Sync the wallet","text":"<p>Now let's build an Esplora client and use it to request transaction history for the wallet.</p> starter-example/src/main.rs<pre><code>// Sync the wallet\nlet client: esplora_client::BlockingClient =\n    Builder::new(\"https://blockstream.info/signet/api/\").build_blocking();\n\nprintln!(\"Syncing wallet...\");\nlet full_scan_request: FullScanRequestBuilder&lt;KeychainKind&gt; = wallet.start_full_scan();\nlet update: FullScanResponse&lt;KeychainKind&gt; = client\n    .full_scan(full_scan_request, STOP_GAP, PARALLEL_REQUESTS)\n    .unwrap();\n\n// Apply the update from the full scan to the wallet\nwallet.apply_update(update).unwrap();\n\nlet balance = wallet.balance();\nprintln!(\"Wallet balance: {} sat\", balance.total().to_sat());\n</code></pre> <p>In cases where you are using new descriptors that do not have a balance yet, the example will request a new address from the wallet and print it out so you can fund the wallet. Remember that this example uses Signet coins!</p> starter-example/src/main.rs<pre><code>if balance.total().to_sat() &lt; 5000 {\n    println!(\"Your wallet does not have sufficient balance for the following steps!\");\n    // Reveal a new address from your external keychain\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\n        \"Send Signet coins to {} (address generated at index {})\",\n        address.address, address.index\n    );\n    wallet.persist(&amp;mut conn).expect(\"Cannot persist\");\n    exit(0)\n}\n</code></pre>","path":["Cookbook","Simple Starter Example"],"tags":[]},{"location":"cookbook/starter-example/#send-a-transaction","level":2,"title":"Send a transaction","text":"<p>For this step you'll need a wallet built with private keys, funded with some Signet satoshis. You can find a faucet here to get some coins.</p> <p>Let's prepare to send a transaction. The two core choices here are where to send the funds and how much to send. We will send funds back to the faucet return address; it's good practice to send test sats back to the faucet when you're done using them.</p> starter-example/src/main.rs<pre><code>// Use a faucet return address\nlet faucet_address =\n    Address::from_str(\"tb1p4tp4l6glyr2gs94neqcpr5gha7344nfyznfkc8szkreflscsdkgqsdent4\")\n        .unwrap()\n        .require_network(Network::Signet)\n        .unwrap();\n\nlet send_amount: Amount = Amount::from_sat(1000);\n</code></pre> <p>Here we are sending 5000 sats back to the faucet (make sure the wallet has at least this much balance, or change this value).</p> <p>Finally we are ready to build, sign, and broadcast the transaction:</p> starter-example/src/main.rs<pre><code>let mut builder = wallet.build_tx();\nbuilder\n    .fee_rate(FeeRate::from_sat_per_vb(4).unwrap())\n    .add_recipient(faucet_address.script_pubkey(), send_amount);\n\nlet mut psbt: Psbt = builder.finish().unwrap();\n\nlet finalized = wallet.sign(&amp;mut psbt, SignOptions::default()).unwrap();\nassert!(finalized);\n\nlet tx = psbt.extract_tx().unwrap();\nclient.broadcast(&amp;tx).unwrap();\nprintln!(\"Transaction broadcast! Txid: {}\", tx.compute_txid());\n</code></pre> <p>We can view our transaction on the mempool.space Signet explorer.</p>","path":["Cookbook","Simple Starter Example"],"tags":[]},{"location":"cookbook/bindings/about/","level":1,"title":"About","text":"<p>The BDK libraries are also available in a multitude of other programming languages. These language bindings libraries all share a common API, which is defined in the bdk-ffi repository. You can read more about why we do this here and how we do it here.</p> <p>The \"common API\" is in fact a wrapper around 9 different Rust libraries, allowing us to produce a single artifact users of language bindings can import as a single dependency.</p> <p>The common API is useful for a few reasons:</p> <ol> <li>While each language has its own syntax, all users of bdk-ffi language bindings share the same API. This ensures we have users in production in many contexts, and feature requests and bug reports are all handled in one place.</li> <li>Documentation and examples of this API are useful for all languages.</li> <li>PRs and community contributions that help one language help all languages.</li> </ol>","path":["Cookbook","Language Bindings","About"],"tags":[]},{"location":"cookbook/bindings/starter-example/","level":1,"title":"Simple Starter Example","text":"","path":["Cookbook","Language Bindings","Simple Starter Example"],"tags":[]},{"location":"cookbook/bindings/starter-example/#overview","level":2,"title":"Overview","text":"<p>So you want to build a bitcoin wallet using BDK. Great! Here is the rough outline of what you need to do just that. A standard, simple example of a bitcoin wallet in BDK-land would require 3 core pillars:</p> <p> </p> <ol> <li>The <code>bdk_wallet</code> library, which will provide two core types: the <code>Wallet</code> and the <code>TxBuilder</code>. This library will handle all the domain logic related to keeping track of which UTXOs you own, what your total balance is, creating and signing transactions, etc.</li> <li>A blockchain client. Your wallet will need to keep track of blockchain data, like new transactions that have been added to the blockchain that impact your wallet, requesting these transactions from a Bitcoin Core node, an Electrum or Esplora server, etc.</li> <li>A persistence mechanism for saving wallet data between sessions (note that this is not actually required). Things like which addresses the wallet has revealed and what is the state of the blockchain on its last sync are things that are kept in persistence and can be loaded on startup.</li> </ol>","path":["Cookbook","Language Bindings","Simple Starter Example"],"tags":[]},{"location":"cookbook/bindings/starter-example/#diving-in","level":2,"title":"Diving in!","text":"<p>This page provides a starter example showcasing how BDK can be used to create, sync, and manage a wallet using an Esplora client as a blockchain data source. Familiarity with this example will help you work through the more advanced pages in this section.</p> <p>You can find working code examples of this example in three programming languages: Swift, Kotlin and Python. (Note: some additional language bindings are available for BDK, see 3rd Party Bindings).</p> <p>Tip</p> <p>To complete this example from top to bottom, you'll need to create new descriptors and replace the ones provided. Once you do so, you'll run the example twice; on first run the wallet will not have any balance and will exit with an address to send funds to. Once that's done, you can run the example again and the wallet will be able to perform the later steps, namely creating and broadcasting a new transaction.</p>","path":["Cookbook","Language Bindings","Simple Starter Example"],"tags":[]},{"location":"cookbook/bindings/starter-example/#create-a-new-project","level":2,"title":"Create a new project","text":"SwiftKotlinPython <pre><code>swift package init --type executable\n</code></pre> <pre><code>gradle init\n</code></pre> <pre><code>python3 -m venv venv\nsource venv/bin/activate\nmkdir src\ntouch src/app.py requirements.txt\n</code></pre>","path":["Cookbook","Language Bindings","Simple Starter Example"],"tags":[]},{"location":"cookbook/bindings/starter-example/#add-required-dependencies","level":2,"title":"Add required dependencies","text":"SwiftKotlinPython <p>Package.swift<pre><code>// swift-tools-version: 5.10\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"QuickstartExample\",\n    platforms: [\n        .macOS(.v12)\n    ],\n    dependencies: [\n        .package(url: \"https://github.com/bitcoindevkit/bdk-swift\", from: \"1.1.0\")\n    ],\n    targets: [\n        .executableTarget(\n            name: \"StarterExample\",\n            dependencies: [\n                .product(name: \"BitcoinDevKit\", package: \"bdk-swift\")\n            ],\n            path: \"Sources\"\n        )\n    ]\n)\n</code></pre> Or, if you're building an iOS app:</p> <ol> <li>From the Xcode File menu, select Add Package Dependencies...</li> <li>Enter <code>https://github.com/bitcoindevkit/bdk-swift</code> into the package repository URL search field and bdk-swift should come up</li> <li>For the Dependency Rule select <code>Exact Version</code>, enter the version number (same as Package.swift) and click Add Package</li> </ol> build.gradle.kts<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    // for JVM\n    implementation(\"org.bitcoindevkit:bdk-jvm:1.1.0\")\n    // for Android\n    implementation(\"org.bitcoindevkit:bdk-android:1.1.0\")\n}\n</code></pre> requirements.txt<pre><code>bdkpython==2.2.0\n</code></pre>","path":["Cookbook","Language Bindings","Simple Starter Example"],"tags":[]},{"location":"cookbook/bindings/starter-example/#use-descriptors","level":2,"title":"Use descriptors","text":"<p>To create a wallet using BDK, we need some descriptors for our wallet. This example uses public descriptors (meaning they cannot be used to sign transactions) on Signet. Step 7 and below will fail unless you replace those public descriptors with private ones of your own and fund them using Signet coins through a faucet. Refer to the Creating Descriptors page for information on how to generate your own private descriptors.</p> <p>Warning</p> <p>Note that if you replace the descriptors after running the example using the provided ones, you must delete or rename the database file or will get an error on wallet load.</p> SwiftKotlinPython <pre><code>let descriptor = try Descriptor(descriptor: \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\", network: Network.signet)\nlet changeDescriptor = try Descriptor(descriptor: \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\", network: Network.signet)\n</code></pre> <pre><code>val descriptor = Descriptor(\"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\", Network.SIGNET)\nval changeDescriptor = Descriptor(\"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\", Network.SIGNET)\n</code></pre> <pre><code>descriptor = Descriptor(\n    \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\",\n    Network.SIGNET,\n)\nchange_descriptor = Descriptor(\n    \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\",\n    Network.SIGNET,\n)\n</code></pre> <p>These are taproot descriptors (<code>tr()</code>) using public keys on Signet (<code>tpub</code>) as described in BIP86. The first descriptor is an HD wallet with a path for generating addresses to give out externally for payments. The second one is used by the wallet to generate addresses to pay ourselves change when sending payments (remember that UTXOs must be spent in full, so you often need to make change).</p>","path":["Cookbook","Language Bindings","Simple Starter Example"],"tags":[]},{"location":"cookbook/bindings/starter-example/#create-or-load-a-wallet","level":2,"title":"Create or load a wallet","text":"<p>Next let's load up our wallet.</p> SwiftKotlinPython <pre><code>let wallet: Wallet\nlet connection: Connection\n\nif FileManager.default.fileExists(atPath: dbFilePath.path) {\n    print(\"Loading up existing wallet\")\n    connection = try Connection(path: dbFilePath.path)\n    wallet = try Wallet.load(\n        descriptor: descriptor,\n        changeDescriptor: changeDescriptor,\n        connection: connection\n    )\n} else {\n    print(\"Creating new wallet\")\n    connection = try Connection(path: dbFilePath.path)\n    wallet = try Wallet(\n        descriptor: descriptor,\n        changeDescriptor: changeDescriptor,\n        network: Network.signet,\n        connection: connection\n    )\n}\n</code></pre> examples/kotlin/starter-example/src/.../App.kt<pre><code>val persistenceExists = File(PERSISTENCE_FILE_PATH).exists()\nval connection = Connection(PERSISTENCE_FILE_PATH)\n\nval wallet = if (persistenceExists) {\n    println(\"Loading up existing wallet\")\n    Wallet.load(\n        descriptor = descriptor,\n        changeDescriptor = changeDescriptor,\n        connection = connection\n    )\n} else {\n    println(\"Creating new wallet\")\n    Wallet(\n        descriptor = descriptor,\n        changeDescriptor = changeDescriptor,\n        network = Network.SIGNET,\n        connection = connection\n    )\n}\n</code></pre> <pre><code>db_path = Path(PERSISTENCE_FILE_PATH)\npersistence_exists = db_path.exists()\npersister = Persister.new_sqlite(PERSISTENCE_FILE_PATH)\n\nif persistence_exists:\n    print(\"Loading up existing wallet\")\n    wallet = Wallet.load(\n        descriptor=descriptor,\n        change_descriptor=change_descriptor,\n        persister=persister,\n    )\nelse:\n    print(\"Creating new wallet\")\n    wallet = Wallet(\n        descriptor=descriptor,\n        change_descriptor=change_descriptor,\n        network=Network.SIGNET,\n        persister=persister,\n    )\n</code></pre>","path":["Cookbook","Language Bindings","Simple Starter Example"],"tags":[]},{"location":"cookbook/bindings/starter-example/#sync-the-wallet","level":2,"title":"Sync the wallet","text":"<p>Now let's build an Esplora client and use it to request transaction history for the wallet.</p> SwiftKotlinPython <pre><code>let esploraClient = EsploraClient(url: \"https://blockstream.info/signet/api/\")\nlet fullScanRequest = try wallet.startFullScan().build()\nlet update = try esploraClient.fullScan(\n    request: fullScanRequest,\n    stopGap: UInt64(10),\n    parallelRequests: UInt64(1)\n)\ntry wallet.applyUpdate(update: update)\nlet balance = wallet.balance()\nprint(\"Wallet balance: \\(balance.total.toSat()) sat\")\n</code></pre> examples/kotlin/starter-example/src/.../App.kt<pre><code>val esploraClient: EsploraClient = EsploraClient(SIGNET_ESPLORA_URL)\nval fullScanRequest: FullScanRequest = wallet.startFullScan().build()\nval update = esploraClient.fullScan(\n    request = fullScanRequest,\n    stopGap = 10uL,\n    parallelRequests = 1uL\n)\nwallet.applyUpdate(update)\nval balance = wallet.balance().total.toSat()\nprintln(\"Balance: $balance\")\n</code></pre> <pre><code>esplora_client = EsploraClient(SIGNET_ESPLORA_URL)\nfull_scan_request = wallet.start_full_scan().build()\nupdate = esplora_client.full_scan(\n    request=full_scan_request, stop_gap=10, parallel_requests=1\n)\nwallet.apply_update(update)\nbalance = wallet.balance().total.to_sat()\nprint(f\"Balance: {balance}\")\n</code></pre> <p>In cases where you are using new descriptors that do not have a balance yet, the example will request a new address from the wallet and print it out so you can fund the wallet. Remember that this example uses Signet coins!</p> SwiftKotlinPython <pre><code>if (balance.total.toSat() &lt; UInt64(5000)) {\n    print(\"Your wallet does not have sufficient balance for the following steps!\");\n    let address = wallet.revealNextAddress(keychain: KeychainKind.external)\n    print(\"Send Signet coins to address \\(address.address) (address generated at index \\(address.index))\")\n    try wallet.persist(connection: connection)\n    exit(0)\n}\n</code></pre> examples/kotlin/starter-example/src/.../App.kt<pre><code>if (balance &lt; 5000uL) {\n    println(\"Your wallet does not have sufficient balance for the following steps!\");\n    val address = wallet.revealNextAddress(KeychainKind.EXTERNAL)\n    println(\"Send Signet coins to address ${address.address} (address generated at index ${address.index})\")\n    wallet.persist(connection)\n    exitProcess(0)\n}\n</code></pre> <pre><code>if balance &lt; 5000:\n    print(\"Your wallet does not have sufficient balance for the following steps!\")\n    address_info = wallet.reveal_next_address(KeychainKind.EXTERNAL)\n    print(\n        f\"Send Signet coins to address {address_info.address} (address generated at index {address_info.index})\"\n    )\n    wallet.persist(persister)\n    sys.exit(0)\n</code></pre>","path":["Cookbook","Language Bindings","Simple Starter Example"],"tags":[]},{"location":"cookbook/bindings/starter-example/#send-a-transaction","level":2,"title":"Send a transaction","text":"<p>For this step you'll need a wallet built with private keys, funded with some Signet satoshis. You can find a faucet here to get some coins.</p> <p>Let's prepare to send a transaction. The two core choices here are where to send the funds and how much to send. We will send funds back to the faucet return address; it's good practice to send test sats back to the faucet when you're done using them.</p> SwiftKotlinPython <pre><code>let faucetAddress: Address = try Address(address: \"tb1p4tp4l6glyr2gs94neqcpr5gha7344nfyznfkc8szkreflscsdkgqsdent4\", network: Network.signet)\nlet amount: Amount = Amount.fromSat(fromSat: UInt64(4000))\n</code></pre> examples/kotlin/starter-example/src/.../App.kt<pre><code>val esploraClient: EsploraClient = EsploraClient(SIGNET_ESPLORA_URL)\nval fullScanRequest: FullScanRequest = wallet.startFullScan().build()\nval update = esploraClient.fullScan(\n    request = fullScanRequest,\n    stopGap = 10uL,\n    parallelRequests = 1uL\n)\nwallet.applyUpdate(update)\nval balance = wallet.balance().total.toSat()\nprintln(\"Balance: $balance\")\n</code></pre> <pre><code>faucet_address = Address(\n    \"tb1p4tp4l6glyr2gs94neqcpr5gha7344nfyznfkc8szkreflscsdkgqsdent4\", Network.SIGNET\n)\namount = Amount.from_sat(4000)\n</code></pre> <p>Here we are sending 5000 sats back to the faucet (make sure the wallet has at least this much balance, or change this value).</p> <p>Finally we are ready to build, sign, and broadcast the transaction:</p> SwiftKotlinPython <pre><code>let psbt: Psbt = try TxBuilder()\n    .addRecipient(script: faucetAddress.scriptPubkey(), amount: amount)\n    .feeRate(feeRate: try FeeRate.fromSatPerVb(satPerVb: UInt64(7)))\n    .finish(wallet: wallet)\n\ntry wallet.sign(psbt: psbt)\nlet tx: Transaction = try psbt.extractTx()\nesploraClient.broadcast(tx)\nprint(\"Transaction broadcast successfully! Txid: \\(tx.computeTxid())\")\n</code></pre> examples/kotlin/starter-example/src/.../App.kt<pre><code>val psbt: Psbt = TxBuilder()\n    .addRecipient(script = faucetAddress.scriptPubkey(), amount = amount)\n    .feeRate(FeeRate.fromSatPerVb(7uL))\n    .finish(wallet)\n\nwallet.sign(psbt)\nval tx: Transaction = psbt.extractTx()\nesploraClient.broadcast(tx)\nprintln(\"Transaction broadcast successfully! Txid: ${tx.computeTxid()}\")\n</code></pre> <pre><code>psbt = (\n    TxBuilder()\n    .add_recipient(faucet_address.script_pubkey(), amount)\n    .fee_rate(FeeRate.from_sat_per_vb(7))\n    .finish(wallet)\n)\n\nwallet.sign(psbt)\ntx = psbt.extract_tx()\nesplora_client.broadcast(tx)\nprint(f\"Transaction broadcast successfully! Txid: {tx.compute_txid()}\")\n</code></pre> <p>We can view our transaction on the mempool.space Signet explorer.</p>","path":["Cookbook","Language Bindings","Simple Starter Example"],"tags":[]},{"location":"cookbook/bindings/wasm/","level":1,"title":"WASM Example","text":"<p>WASM bindings can be used to access rust code from virtually any JavaScript environment: browsers, Node.js, ReactNative, etc.</p> <p>Info</p> <p>This page details how to build a custom WASM package that uses BDK rust crate under the hood. If you want an out of the box solution for JS(WASM) bindings for BDK which don't require writing any rust code, see the WASM section on the 3rd Party Bindings page for a pre-packaged npm module.</p> <p>Because rust can compile to WASM, it is possible to use BDK in the browser. However, there are a few limitations to keep in mind which will be highlighted in this example. That being said, there are perfectly viable work-arounds for these limitations that should suffice for most use cases.</p> <p>Warning</p> <p>There are several limitations to using BDK in WASM. Basically any functionality that requires OS access is not directly available in WASM and must therefore be handled in JavaScript. Some key limitations include:</p> <ul> <li>No access to the file system</li> <li>No access to the system time</li> <li>Network access is limited to http(s)</li> </ul>","path":["Cookbook","Language Bindings","WASM Example"],"tags":[]},{"location":"cookbook/bindings/wasm/#wasm-considerations-overview","level":2,"title":"WASM Considerations Overview","text":"","path":["Cookbook","Language Bindings","WASM Example"],"tags":[]},{"location":"cookbook/bindings/wasm/#no-access-to-the-file-system","level":3,"title":"No access to the file system","text":"<p>With no direct access to the file system, persistence cannot be handled by BDK directly. Instead, an in memory wallet must be used in the WASM environment, and the data must be exported through a binding to the JavaScript environment to be persisted.</p>","path":["Cookbook","Language Bindings","WASM Example"],"tags":[]},{"location":"cookbook/bindings/wasm/#no-access-to-the-system-time","level":3,"title":"No access to the system time","text":"<p>Any function that requires system time, such as any sort of timestamp, must access system time through a wasm binding to the JavaScript environment. This means some BDK functions that are commonly used in rust won't work in WASM and instead an alternate rust function that takes a timestamp as an argument must be used (I.E. instead of <code>.apply_update()</code> we must use <code>.apply_update_at()</code>).</p>","path":["Cookbook","Language Bindings","WASM Example"],"tags":[]},{"location":"cookbook/bindings/wasm/#network-access-is-limited-to-https","level":3,"title":"Network access is limited to http(s)","text":"<p>This effectively means that the blockchain client must be an Esplora instance. Both RPC and Electrum clients require sockets and will not work for BDK in a WASM environment out of the box.</p>","path":["Cookbook","Language Bindings","WASM Example"],"tags":[]},{"location":"cookbook/bindings/wasm/#troubleshooting","level":2,"title":"Troubleshooting","text":"<p>WASM errors can be quite cryptic, so it's important to understand the limitations of the WASM environment. One common error you might see while running a BDK function through a WASM binding in the browser is <code>unreachable</code>. This error likely will not point you to the actual BDK function that is causing the error. Instead you need to be able to assess whether you are calling a function that uses a rust feature that is unsupported in the WASM environment. For example, if you do a scan and then try to use <code>.apply_update()</code> you will get an <code>unreachable</code> error. This is because <code>.apply_update()</code> requires system time, which is not available in the WASM environment. Instead you need to use <code>.apply_update_at()</code> which takes an explicit timestamp as an argument (see below).</p>","path":["Cookbook","Language Bindings","WASM Example"],"tags":[]},{"location":"cookbook/bindings/wasm/#wasm-app-example","level":2,"title":"WASM App Example","text":"<p>In this example we will cover basic BDK functionality in a WASM environment. We will show code snippets for both the rust and JavaScript necessary to create a custom WASM package, and we will highlight the key differences from the plain rust examples (due to WASM limitations).</p> <p>Info</p> <p>The WASM example code is split into two project folders: a rust project that uses wasm-pack to compile rust code to WASM files, and a JavaScript project that pulls the WASM project as a dependency. The JS project represents the web app and the rust project is used to generate an npm module.</p>","path":["Cookbook","Language Bindings","WASM Example"],"tags":[]},{"location":"cookbook/bindings/wasm/#initializing-a-wallet","level":3,"title":"Initializing a Wallet","text":"<p>From JS running in our browser, first we need our descriptors:</p> <pre><code>const externalDescriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\";\nconst internalDescriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\";\n</code></pre> <p>Then we can initialize the wallet, we'll use some conditional logic here to either 1) create a new wallet and perform a full scan, or 2) load a wallet from stored data and sync it to get recent updates.</p> <pre><code>let walletDataString = Store.load();\nconsole.log(\"Wallet data:\", walletDataString);\n\nlet wallet;\nif (!walletDataString) {\n    console.log(\"Creating new wallet\");\n    wallet = new WalletWrapper(\n        \"signet\",\n        externalDescriptor,\n        internalDescriptor,\n        \"https://mutinynet.com/api\"\n    );\n\n    console.log(\"Performing Full Scan...\");\n    await wallet.scan(2);\n\n    const stagedDataString = wallet.take_staged();\n    console.log(\"Staged:\", stagedDataString);\n\n    Store.save(stagedDataString);\n    console.log(\"Wallet data saved to local storage\");\n    walletDataString = stagedDataString;\n} else {\n    console.log(\"Loading wallet\");\n    wallet = WalletWrapper.load(\n        walletDataString,\n        \"https://mutinynet.com/api\",\n        externalDescriptor,\n        internalDescriptor\n    );\n\n    console.log(\"Syncing...\");\n    await wallet.sync(2);\n\n    const stagedDataString = wallet.take_staged();\n    console.log(\"Staged:\", stagedDataString);\n\n    Store.save(stagedDataString);\n    console.log(\"Wallet data saved to local storage\");\n}\n</code></pre>","path":["Cookbook","Language Bindings","WASM Example"],"tags":[]},{"location":"cookbook/bindings/wasm/#network-consideration","level":4,"title":"Network Consideration","text":"<p>Notice we are including blockchain client details in wallet initialization (Signet, and the esplora url). This is because we are forced to use esplora, so we may as well initialize the client at the same time as the wallet.</p> <p>Here is the relevant rust code:</p> <pre><code>#[wasm_bindgen(constructor)]\npub fn new(\n    network: String,\n    external_descriptor: String,\n    internal_descriptor: String,\n    esplora_url: String,\n) -&gt; Result&lt;WalletWrapper, String&gt; {\n    let network = match network.as_str() {\n        \"mainnet\" =&gt; Network::Bitcoin,\n        \"testnet\" =&gt; Network::Testnet,\n        \"testnet4\" =&gt; Network::Testnet4,\n        \"signet\" =&gt; Network::Signet,\n        \"regtest\" =&gt; Network::Regtest,\n        _ =&gt; return Err(\"Invalid network\".into()),\n    };\n\n    let wallet_opt = Wallet::load()\n        .descriptor(KeychainKind::External, Some(external_descriptor.clone()))\n        .descriptor(KeychainKind::Internal, Some(internal_descriptor.clone()))\n        .extract_keys()\n        .check_network(network)\n        .load_wallet_no_persist(ChangeSet::default())\n        .map_err(|e| format!(\"{:?}\", e))?;\n\n    let wallet = match wallet_opt {\n        Some(wallet) =&gt; wallet,\n        None =&gt; Wallet::create(external_descriptor, internal_descriptor)\n            .network(network)\n            .create_wallet_no_persist()\n            .map_err(|e| format!(\"{:?}\", e))?,\n    };\n\n    let client = esplora_client::Builder::new(&amp;esplora_url)\n        .max_retries(6)\n        .build_async_with_sleeper()\n        .map_err(|e| format!(\"{:?}\", e))?;\n\n    Ok(WalletWrapper { wallet, client })\n}\n\npub fn load(\n    changeset_str: &amp;str,\n    url: &amp;str,\n    external_descriptor: &amp;str,\n    internal_descriptor: &amp;str,\n) -&gt; JsResult&lt;WalletWrapper&gt; {\n    let changeset_value: Value = serde_json::from_str(changeset_str)?;\n    let changeset: ChangeSet = serde_json::from_value(changeset_value)?;\n\n    let wallet_opt = Wallet::load()\n        .descriptor(\n            KeychainKind::External,\n            Some(external_descriptor.to_string()),\n        )\n        .descriptor(\n            KeychainKind::Internal,\n            Some(internal_descriptor.to_string()),\n        )\n        .extract_keys()\n        .load_wallet_no_persist(changeset)?;\n\n    let wallet = match wallet_opt {\n        Some(wallet) =&gt; wallet,\n        None =&gt; return Err(JsError::new(\"Failed to load wallet, check the changeset\")),\n    };\n\n    let client = esplora_client::Builder::new(&amp;url).build_async_with_sleeper()?;\n\n    Ok(WalletWrapper { wallet, client })\n}\n\npub async fn scan(&amp;mut self, stop_gap: usize) -&gt; Result&lt;(), String&gt; {\n    let wallet = &amp;mut self.wallet;\n    let client = &amp;self.client;\n\n    let request = wallet.start_full_scan();\n\n    let update = client\n        .full_scan(request, stop_gap, PARALLEL_REQUESTS)\n        .await\n        .map_err(|e| format!(\"{:?}\", e))?;\n\n    let now = (Date::now() / 1000.0) as u64;\n    wallet\n        .apply_update_at(update, now)\n        .map_err(|e| format!(\"{:?}\", e))?;\n\n    Ok(())\n}\n\npub async fn sync(&amp;mut self, parallel_requests: usize) -&gt; JsResult&lt;()&gt; {\n    let request = self.wallet.start_sync_with_revealed_spks();\n    let update = self.client.sync(request, parallel_requests).await?;\n\n    let now = (Date::now() / 1000.0) as u64;\n    self.wallet.apply_update_at(update, now)?;\n\n    Ok(())\n}\n</code></pre> <p>The first time you load the page in your browser, you should see info in the console confirming that a new wallet was created and a full scan was performed. If you then reload the page you should see that the wallet was loaded from the previously saved data and a sync was performed instead of a full scan.</p>","path":["Cookbook","Language Bindings","WASM Example"],"tags":[]},{"location":"cookbook/bindings/wasm/#system-time-consideration","level":4,"title":"System Time Consideration","text":"<p>Notice we are using a JS binding to access system time with <code>js_sys::Date::now()</code>, then passing that timestamp to the <code>apply_update_at()</code> function, rather than attempting to use the <code>.apply_update()</code> function which would throw an error.</p>","path":["Cookbook","Language Bindings","WASM Example"],"tags":[]},{"location":"cookbook/bindings/wasm/#persistence-consideration","level":4,"title":"Persistence Consideration","text":"<p>Also notice we are using an in-memory wallet with <code>.create_wallet_no_persist()</code>. If you try to use persistence through file or database you will get an error because those features require OS access. Instead we have to create a binding to pass the wallet data to the JavaScript environment where we can handle persistence. We have a method to grab the new updates to the wallet data, and a method to merge new updates with existing data. With this simple approach to persistence we must always merge existing data with the updates unless there is no existing data (i.e. after new wallet creation). The rust side methods to extract the wallet data are:</p> <pre><code>pub fn take_staged(&amp;mut self) -&gt; JsResult&lt;String&gt; {\n    match self.wallet.take_staged() {\n        Some(changeset) =&gt; {\n            let value = serde_json::to_value(&amp;changeset)?;\n            Ok(serde_json::to_string(&amp;value)?)\n        }\n        None =&gt; Ok(\"null\".to_string()),\n    }\n}\n\npub fn take_merged(&amp;mut self, previous: String) -&gt; JsResult&lt;String&gt; {\n    match self.wallet.take_staged() {\n        Some(curr_changeset) =&gt; {\n            let previous_value: Value = serde_json::from_str(&amp;previous)?;\n            let mut previous_changeset: ChangeSet = serde_json::from_value(previous_value)?;\n            previous_changeset.merge(curr_changeset);\n            let final_value = serde_json::to_value(&amp;previous_changeset)?;\n            Ok(serde_json::to_string(&amp;final_value)?)\n        }\n        None =&gt; Ok(\"null\".to_string()),\n    }\n}\n</code></pre> <p>Notice we're converting the wallet data to a JSON string so that it plays nicely with WASM; and on the JS side we'll save our data string with a minimal custom browser store:</p> <pre><code>// simple string storage example\nconst Store = {\n    save: data =&gt; {\n        if (!data) {\n            console.log(\"No data to save\");\n            return;\n        }\n        localStorage.setItem(\"walletData\", data);  // data is already a JSON string\n    },\n    load: () =&gt; {\n        return localStorage.getItem(\"walletData\");  // return the JSON string directly\n    }\n}\n</code></pre> <p>This is just to show an example of how the wallet data can be persisted. We're using local storage here, but in practice a wallet app would generally use cloud storage of some sort since browser local storage tends to be temporary.</p>","path":["Cookbook","Language Bindings","WASM Example"],"tags":[]},{"location":"cookbook/bindings/wasm/#balance-and-addresses","level":3,"title":"Balance and Addresses","text":"<p>We can now get the balance of our wallet and generate a new address. Here is the JS code:</p> <pre><code>// Test balance\nconsole.log(\"Balance:\", wallet.balance());\n\n// Test address generation\nconsole.log(\"New address:\", wallet.reveal_next_address());\n\n// handle changeset merge on rust side\nconst mergedDataString = wallet.take_merged(walletDataString);\n\nconsole.log(\"Merged:\", mergedDataString);\n\nStore.save(mergedDataString);\nconsole.log(\"new address saved\");\n</code></pre> <p>Here is the rust code that gets called:</p> <pre><code>pub fn balance(&amp;self) -&gt; u64 {\n    let balance = self.wallet.balance();\n    balance.total().to_sat()\n}\n\npub fn reveal_next_address(&amp;mut self) -&gt; String {\n    let address = self.wallet.reveal_next_address(KeychainKind::External);\n\n    address.to_string()\n}\n</code></pre> <p>Notice we call <code>take_merged()</code> and <code>Store.save()</code> after generating a new address so our wallet keeps track of generated addresses (so we don't re-use them). If you reload the browser you can see the generated address value updated along with the index.</p>","path":["Cookbook","Language Bindings","WASM Example"],"tags":[]},{"location":"cookbook/keys-descriptors/descriptors/","level":1,"title":"Creating Keys and Descriptors","text":"<p>BDK is a descriptor-first library. This page explores how to build them and how they interact with other standards like BIP-39 recovery phrases.</p> <p>Danger</p> <p>The keys and descriptors used in The Book of BDK are for illustration purposes only; UNDER NO CIRCUMSTANCES should any of the keys or descriptors containing private data be used for real money. Entropy generation should be carried out in a secure environment using cryptographically secure random number generators (CSPRNG).</p>","path":["Cookbook","Keys and Descriptors","Creating Keys and Descriptors"],"tags":[]},{"location":"cookbook/keys-descriptors/descriptors/#using-descriptor-templates","level":2,"title":"Using descriptor templates","text":"<p>BDK offers utility constructs called descriptor templates, which allow you to build descriptors for the four most common script types (BIP 44/49/84/86) with minimal effort.</p> <p>The following will build and print the full string representation of taproot (BIP-86) internal and external descriptors. We print both the public key descriptors (for HD wallet address generation only) and private key descriptors (for full wallet functionality including transaction signing).</p> <pre><code>let mut seed: [u8; 32] = [0u8; 32];\nrand::thread_rng().fill_bytes(&amp;mut seed);\n\nlet network: Network = Network::Signet;\nlet xprv: Xpriv = Xpriv::new_master(network, &amp;seed).unwrap();\nprintln!(\"Generated Master Private Key:\\n{}\\nWarning: be very careful with private keys when using MainNet! We are logging these values for convenience only because this is an example on SigNet.\\n\", xprv);\n\nlet (descriptor, key_map, _) = Bip86(xprv, KeychainKind::External)\n    .build(Network::Signet)\n    .expect(\"Failed to build external descriptor\");\n\nlet (change_descriptor, change_key_map, _) = Bip86(xprv, KeychainKind::Internal)\n    .build(Network::Signet)\n    .expect(\"Failed to build internal descriptor\");\n\nlet descriptor_string_priv = descriptor.to_string_with_secret(&amp;key_map);\nlet change_descriptor_string_priv = change_descriptor.to_string_with_secret(&amp;change_key_map);\n</code></pre>","path":["Cookbook","Keys and Descriptors","Creating Keys and Descriptors"],"tags":[]},{"location":"cookbook/keys-descriptors/recovery-phrases/","level":1,"title":"Generate Descriptors from Recovery Phrases","text":"<p>BDK wallets require the use of descriptors, but recovery phrases (also called seed phrases) are a common and popular backup solution. Creating descriptors from a recovery phrase is a common workflow and BDK makes this easy with its descriptor templates, which are offered for common descriptors (BIP 44/49/84/86).</p> <p>Feature Flags</p> <p>The current example requires the feature <code>keys-bip39</code> for <code>bdk_wallet</code>. Add it to your <code>Cargo.toml</code> file with:</p> <pre><code>bdk_wallet = { version = \"2.2.0\", features = [\"keys-bip39\"] }\n</code></pre>","path":["Cookbook","Keys and Descriptors","Generate Descriptors from Recovery Phrases"],"tags":[]},{"location":"cookbook/keys-descriptors/recovery-phrases/#example","level":3,"title":"Example","text":"<pre><code>let recovery_phrase: &amp;str = \"awesome awesome awesome awesome awesome awesome awesome awesome awesome awesome awesome awesome\";\nlet mnemonic = Mnemonic::parse(recovery_phrase).expect(\"Invalid seed! Be sure to replace the value of RECOVERY_PHRASE with your own 12 word seed phrase.\");\nlet seed = mnemonic.to_seed(\"\");\nlet xprv = Xpriv::new_master(Network::Signet, &amp;seed).expect(\"Failed to create master key\");\n\nprintln!(\"# Master Private Key\\n{xprv}\\nWarning: be very careful with seeds and private keys when using MainNet! We are logging these values for convenience and demonstration purposes only.\\n\");\n\nlet (descriptor, key_map, _) = Bip86(xprv, KeychainKind::External)\n    .build(Network::Signet)\n    .expect(\"Failed to build external descriptor\");\n\nlet (change_descriptor, change_key_map, _) = Bip86(xprv, KeychainKind::Internal)\n    .build(Network::Signet)\n    .expect(\"Failed to build internal descriptor\");\n</code></pre>","path":["Cookbook","Keys and Descriptors","Generate Descriptors from Recovery Phrases"],"tags":[]},{"location":"cookbook/persistence/memory/","level":1,"title":"In-Memory Wallet","text":"<p>The simplest wallet is one that does not have any persistence. All information about the wallet is held in memory, and will be destroyed upon termination of the process.</p> <p>In-memory implies that the addresses the wallet has revealed, the syncing that has been performed including data on the transaction graph will not persist when the wallet is destroyed, and related operations will need to be performed again.</p> <p>In general, this means performing a <code>full_scan()</code> when starting the wallet, because it has no knowledge of which addresses were given out and which scripts still have balances.</p> <p>See our page on the difference between the full scan and sync operations for more on this topic.</p>","path":["Cookbook","Persistence","In-Memory Wallet"],"tags":[]},{"location":"cookbook/persistence/memory/#example","level":2,"title":"Example","text":"<p>The in-memory wallet does not require any additional dependencies beyond the <code>bdk_wallet</code> dependency:</p> Cargo.toml<pre><code>[dependencies]\nbdk_wallet = { version = \"2.2.0\" }\n</code></pre> <p>To create an in-memory wallet, simply call <code>create_wallet_no_persist()</code> on the <code>Wallet</code> builder:</p> main.rs<pre><code>let mut wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n    .network(Network::Signet)\n    .create_wallet_no_persist()\n    .expect(\"valid wallet\");\n</code></pre> <p></p>","path":["Cookbook","Persistence","In-Memory Wallet"],"tags":[]},{"location":"cookbook/persistence/sqlite/","level":1,"title":"SQLite Database","text":"<p>The SQLite persistence is a great default for many use cases, and is a good place to start if you're not sure which persistence to choose from.</p> <p>By default when using the <code>bdk_wallet</code> library, all information about the wallet is held in memory, and will be destroyed upon termination of the process unless saved to persistence. </p> <p>When information important to the wallet is added to it, the wallet will add it to its staged area. Whenever you want to save this information to persistence, call the <code>Wallet.persist(&amp;mut db)</code>.</p> <p>The operations that affect the wallet and produce a changeset are things like:</p> <ul> <li>Revealing new addresses</li> <li>Sync operations that pick up new UTXOs</li> </ul> <p>Once those things are persisted, upon loading of the database changeset the wallet would be able to rehydrate its TxGraph, which includes UTXOs, transaction history, and latest blocks known to the wallet. This means that a wallet that's been loaded from such a persistence will not require a Full Scan but rather simply a Sync.</p> <p>See our page on the difference between the full scan and sync operations for more on this topic.</p>","path":["Cookbook","Persistence","SQLite Database"],"tags":[]},{"location":"cookbook/persistence/sqlite/#example","level":2,"title":"Example","text":"<p>The sqlite wallet does not require any additional dependencies above the <code>bdk_wallet</code> dependency:</p> Cargo.toml<pre><code>[dependencies]\nbdk_wallet = { version = \"2.1.0\", features = [\"rusqlite\"] }\n</code></pre> <p>To load an existing sqlite-based persisted wallet use <code>Wallet::load()</code>. You may then optionally verify the loaded descriptors match what you expect. If the provided descriptors contain private keys you can also extract these keys into the wallets keystore. Private keys are never stored in the wallet database. You may also verify the wallet network during loading.</p> <pre><code>let network = Network::Signet;\nlet file_path = \"test_wallet.sqlite3\";\nlet mut conn = rusqlite::Connection::open(file_path)?;\n\nlet wallet_opt = Wallet::load()\n    .descriptor(KeychainKind::External, Some(EXTERNAL_DESCRIPTOR))\n    .descriptor(KeychainKind::Internal, Some(INTERNAL_DESCRIPTOR))\n    .extract_keys() // only needed if using private key descriptors\n    .check_network(network)\n    .load_wallet(&amp;mut conn)?;\n</code></pre> <p>If during wallet loading no wallet database file is found you can create a sqlite-based persisted wallet with <code>Wallet::create()</code> with a valid db connection and other wallet builder parameters:</p> <pre><code>let mut wallet = match wallet_opt {\n    Some(wallet) =&gt; {\n        println!(\"Loaded existing wallet database.\");\n        wallet\n    }\n    None =&gt; {\n        println!(\"Creating new wallet database.\");\n        Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n            .network(network)\n            .create_wallet(&amp;mut conn)?\n    }\n};\n</code></pre> <p>After performing an operation that returns data that should be persisted, use the <code>persist()</code> method on the wallet:</p> <pre><code>// Reveal a new address from your external keychain\nlet address = wallet.reveal_next_address(KeychainKind::External);\nwallet.persist(&amp;mut conn)?;\n// Only share new address with user after successfully persisting wallet\nprintln!(\n    \"Generated address {} at index {}\",\n    address.address, address.index\n);\n</code></pre> <p></p>","path":["Cookbook","Persistence","SQLite Database"],"tags":[]},{"location":"cookbook/syncing/electrum/","level":1,"title":"Sync a Wallet with Electrum","text":"<p>Syncing with Electrum uses what we refer to as SPK-based syncing (see our Full Scan vs Sync page for more information on this).</p> <p>The workflow for a full scan or sync consists of a 3-step process:</p> <ol> <li>Ask the wallet for the data structure required.</li> <li>Pass it to your blockchain client and request a full scan or sync.</li> <li>The client returns an update, which you then apply to the wallet.</li> </ol> <p>This workflow ensures that the wallet structure is not blocked while the syncing operation is performed.</p>","path":["Cookbook","Syncing","Sync a Wallet with Electrum"],"tags":[]},{"location":"cookbook/syncing/electrum/#add-required-bdk-dependencies-to-your-cargotoml-file","level":3,"title":"Add required bdk dependencies to your <code>Cargo.toml</code> file","text":"Cargo.toml<pre><code>[dependencies]\nbdk_wallet = { version = \"2.1.0\" }\nbdk_electrum = { version = \"0.23.1\" }\n</code></pre>","path":["Cookbook","Syncing","Sync a Wallet with Electrum"],"tags":[]},{"location":"cookbook/syncing/electrum/#create-and-sync-the-wallet","level":3,"title":"Create and sync the wallet","text":"main.rs<pre><code>use bdk_electrum::electrum_client::Client;\nuse bdk_electrum::{electrum_client, BdkElectrumClient};\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::AddressInfo;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::Wallet;\n\nconst STOP_GAP: usize = 50;\nconst BATCH_SIZE: usize = 5;\nconst EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/0/*)#g9xn7wf9\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/1/*)#e3rjrmea\";\n\nfn main() {\n    let mut wallet: Wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n        .network(Network::Signet)\n        .create_wallet_no_persist()\n        .unwrap();\n\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\n        \"Generated address {} at index {}\",\n        address.address, address.index\n    );\n\n    // Create the Electrum client\n    let client: BdkElectrumClient&lt;Client&gt; =\n        BdkElectrumClient::new(electrum_client::Client::new(\"ssl://mempool.space:60602\").unwrap());\n\n    // Perform the initial full scan on the wallet\n    let full_scan_request = wallet.start_full_scan();\n    let update = client\n        .full_scan(full_scan_request, STOP_GAP, BATCH_SIZE, true)\n        .unwrap();\n\n    wallet.apply_update(update).unwrap();\n    let balance = wallet.balance();\n    println!(\"Wallet balance: {} sat\", balance.total().to_sat());\n}\n</code></pre>","path":["Cookbook","Syncing","Sync a Wallet with Electrum"],"tags":[]},{"location":"cookbook/syncing/esplora/","level":1,"title":"Sync a Wallet with Esplora","text":"<p>Syncing with Esplora uses what we refer to as SPK-based syncing (see our Full Scan vs Sync page for more information on this).</p> <p>The workflow for a full scan or sync consists of a 3-step process:</p> <ol> <li>Ask the wallet for the data structure required.</li> <li>Pass it to your blockchain client and request a full scan or sync.</li> <li>The client returns an update, which you then apply to the wallet.</li> </ol> <p>This workflow ensures that the wallet structure is not blocked while the syncing operation is performed.</p>","path":["Cookbook","Syncing","Sync a Wallet with Esplora"],"tags":[]},{"location":"cookbook/syncing/esplora/#add-required-bdk-dependencies-to-your-cargotoml-file","level":3,"title":"Add required bdk dependencies to your Cargo.toml file","text":"Cargo.toml<pre><code>[dependencies]\nbdk_wallet = { version = \"2.1.0\" }\nbdk_esplora = { version = \"0.22.1\", features = [\"blocking\"] }\nanyhow = \"1\"\n</code></pre>","path":["Cookbook","Syncing","Sync a Wallet with Esplora"],"tags":[]},{"location":"cookbook/syncing/esplora/#create-and-sync-the-wallet","level":3,"title":"Create and sync the wallet","text":"main.rs<pre><code>use anyhow::Error;\nuse bdk_esplora::esplora_client::Builder;\nuse bdk_esplora::{esplora_client, EsploraExt};\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::chain::spk_client::{\n    FullScanRequestBuilder, FullScanResponse, SyncRequestBuilder, SyncResponse,\n};\nuse bdk_wallet::AddressInfo;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::Wallet;\n\nconst STOP_GAP: usize = 50;\nconst PARALLEL_REQUESTS: usize = 1;\nconst EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/0/*)#g9xn7wf9\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/1/*)#e3rjrmea\";\n\nfn main() -&gt; Result&lt;(), Error&gt; {\n    let mut wallet: Wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n        .network(Network::Signet)\n        .create_wallet_no_persist()?;\n\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\n        \"Generated address {} at index {}\",\n        address.address, address.index\n    );\n\n    // Create the Esplora client\n    let client: esplora_client::BlockingClient =\n        Builder::new(\"https://blockstream.info/signet/api/\").build_blocking();\n\n    // Full scan the wallet\n    let full_scan_request: FullScanRequestBuilder&lt;KeychainKind&gt; = wallet.start_full_scan();\n    let full_scan_response: FullScanResponse&lt;KeychainKind&gt; =\n        client.full_scan(full_scan_request, STOP_GAP, PARALLEL_REQUESTS)?;\n\n    // Apply the full scan response to the wallet\n    wallet.apply_update(full_scan_response)?;\n\n    // Sync the wallet\n    let sync_request: SyncRequestBuilder&lt;(KeychainKind, u32)&gt; =\n        wallet.start_sync_with_revealed_spks();\n    let sync_response: SyncResponse = client.sync(sync_request, PARALLEL_REQUESTS)?;\n\n    // Apply the sync response to the wallet\n    wallet.apply_update(sync_response)?;\n\n    let balance = wallet.balance();\n    println!(\"Wallet balance: {} sat\", balance.total().to_sat());\n\n    Ok(())\n}\n</code></pre>","path":["Cookbook","Syncing","Sync a Wallet with Esplora"],"tags":[]},{"location":"cookbook/syncing/full-scan-vs-sync/","level":1,"title":"Full Scan vs Sync","text":"<p>Two of the four blockchain client libraries maintained by BDK (Electrum and Esplora) use what we refer to as SPK-based syncing (as opposed to block-by-block syncing). This SPK-based syncing relies on two concepts we call Full Scan and Sync. This page explains the difference between the two, the tradeoffs made when choosing each, and recommendations on when to use them.</p>","path":["Cookbook","Syncing","Full Scan vs Sync"],"tags":[]},{"location":"cookbook/syncing/full-scan-vs-sync/#full-scan","level":2,"title":"Full Scan","text":"<p>A full scan is an operation that aims to build a complete picture of a wallet's UTXOs from scratch, with no prior data or knowledge about the wallet. It involves querying the blockchain data client for ScriptPubKeys that the wallet owns, typically at a number of indices on the wallet's keychains. </p> <p>Because the wallet doesn't know which scripts/addresses have been given out and potentially have funds associated with them, it needs to query the blockchain client for a group of addresses, see if any of those have balances, and keep asking for more until a number of addresses in a row for each keychain are unused (the exact number is configurable and is what's typically known as a stop gap). The operation also returns a new chain tip the wallet uses to update its <code>LocalChain</code>.</p> <p>A full scan is needed in cases where the wallet is unknown and is not loaded from persistence, or in cases where other software wallets might have revealed/used addresses on the keychains since the last time the wallet was used (like how some users might have wallets they use on both mobile apps and desktop applications, and the mobile wallet has no way of knowing if the desktop wallet was used since the last time it was synced up).</p>","path":["Cookbook","Syncing","Full Scan vs Sync"],"tags":[]},{"location":"cookbook/syncing/full-scan-vs-sync/#sync","level":2,"title":"Sync","text":"<p>A sync is a related operation which can be thought of as \"catching up\" on the latest things that have happened on the chain since the last full scan or sync. A sync only makes sense if the list of addresses given out is known, and will query the blockchain data client for those scripts only. It also returns a new chain tip the wallet uses to update its <code>LocalChain</code>.</p> <p>A sync is a smaller and more optimal operation than a full scan, and should often be used in cases after an initial full scan has been performed.</p>","path":["Cookbook","Syncing","Full Scan vs Sync"],"tags":[]},{"location":"cookbook/syncing/full-scan-vs-sync/#practical-examples","level":2,"title":"Practical Examples","text":"<p>Here are 4 different examples with wallets of different sizes and stop gap choices. The numbers in the Full Scan and Sync columns are the resulting number of scripts requested to the Electrum or Esplora instances.</p> Example Addr. Revealed Stop Gap Full Scan Sync A 7 20 27 7 B 7 1000 1007 7 C 500 20 520 500 D 500 1000 1500 500","path":["Cookbook","Syncing","Full Scan vs Sync"],"tags":[]},{"location":"cookbook/syncing/full-scan-vs-sync/#additional-considerations-server-load","level":2,"title":"Additional Considerations  Server Load","text":"<p>Note that the choice of full scan vs sync as well as the stop gap on the wallet influences the load on the server infrastructure that services those requests. Whether these servers are maintained by you or you are using publicly available servers, understanding those choices is important.</p> <p>In particular, the difference between a full scan and a sync depends on your choice of stop gap and the current size of the wallet like so:</p> <ol> <li>If the stop gap is small, the difference between your sync and full scan will be smaller than if the stop gap is very big. Wallets A and B above have revealed 7 addresses each, yet wallet B's full scan is more than 100x its sync while wallet A's is only 4x. Using a sync on wallet B will make a big difference on your server load (particularly if you sync often).</li> <li>The difference between the full scan and sync diminishes the bigger the wallet becomes. On a very small wallet (wallets A and B above), the stop gap makes a big part of the number of SPKs synced, whereas for bigger wallets , the stop gap makes up a much smaller percentage of the total number of SPKs synced. For example on wallet C (big wallet but small stop gap) the difference between the full scan and the sync is minimal.</li> </ol>","path":["Cookbook","Syncing","Full Scan vs Sync"],"tags":[]},{"location":"cookbook/syncing/full-scan-vs-sync/#additional-considerations-sync-but-not-always","level":2,"title":"Additional Considerations  Sync, But Not Always!","text":"<p>We can think of a sync as a more narrow but optimized approach to syncing. It works really well for some situations, but is less applicable as a \"one-worklflow-to-rule-them-all\". In particular, wallets where the user might also be using their descriptors on other software can create problems with the sync workflow, since the wallet is not aware that new addresses have been revealed, and will not include them in its sync request.</p> <p>Here are situations for which sync works and performs best:</p> <ul> <li>Cases where you know the user only uses their descriptors with the current wallet (for example if the user has specified this as a toggle in settings), and a full scan has already been performed once.</li> <li>Situations where you call your syncing workflow on a loop, and you can safely assume that you're the only user of the descriptors at any given time. For example if you loop on 15s intervals you could have your loop full scan on first iteration and sync on further iterations, with a full scan every X number of minutes/iterations.</li> </ul> <p>Production applications need either a mix of both (and if so the option to trigger a full scan on user request, not just on first startup), or, if they want to only use one, use the full scan (to cover all cases and situations where users use their backups on different wallets/software).</p>","path":["Cookbook","Syncing","Full Scan vs Sync"],"tags":[]},{"location":"cookbook/syncing/full-scan-vs-sync/#additional-considerations-general-heuristics","level":2,"title":"Additional Considerations  General Heuristics","text":"<p>The following heuristics work well for most standard wallets:</p> <ol> <li>If you are recovering a wallet which currently holds or has ever held a balance or are creating a wallet from scratch, your first syncing operation should be a full scan. This allows the wallet to discover which scripts have been used and create an accurate overall balance. If your sofware is certain that the users is only using their descriptors with this wallet, all other syncing operations can be sync.</li> <li>If you are loading a wallet from persistence for which a full scan has already been performed and related data has been persisted, your syncing operations can be sync. If you believe some addresses have been revealed in the meantime, do a full scan on startup.</li> <li>If you are operating on a wallet which is shared with other entities which might reveal addresses, your local wallet and its <code>TxGraph</code> will not know about these revealed scripts. In this case, and if you suspect addresses might have been revealed, you should perform a full scan.</li> </ol>","path":["Cookbook","Syncing","Full Scan vs Sync"],"tags":[]},{"location":"cookbook/syncing/full-scan-vs-sync/#additional-considerations-really-big-wallets","level":2,"title":"Additional Considerations  Really Big Wallets","text":"<p>On really big wallets, a custom, application-defined choice of which spks to sync at any given time/trigger is probably more appropriate.</p> <p>For example, if a wallet has 2500 addresss revealed and your application tries to stay on a 10s loop... it is not a good idea (and doesn't really make sense anyway) to try and sync it all on every iteration.</p> <p>Some pooling of the spks in different buckets would probably work best, and this would be defined at the application layer. Variables to include in the choice of which SPKs to sync would probably include last known transaction for the SPK and last time it was synced.</p> <p></p>","path":["Cookbook","Syncing","Full Scan vs Sync"],"tags":[]},{"location":"cookbook/syncing/kyoto/","level":1,"title":"Sync a wallet with Kyoto","text":"<p>BIP157 and BIP158 define a protocol for light clients to sync with the Bitcoin network without downloading the entire set of blocks in the chain of most work. These proposals define compact block filters, which allow a client to download a small commitment for the scripts contained in each block. These commitments, or filters, may be checked for inclusion of scripts owned by a user. In the event of a match, the light client may download and verify a block indeed contains a relevant transaction. Syncing via compact block filters offers privacy advantages over other chain sources, as the nodes serving the blocks to the client are only aware that the client is interested in an entire block, which may contain thousands of transactions.</p> <p>One such implementation of this protocol is Kyoto, which is a node and client for compact block filter based syncing. The <code>bdk_kyoto</code> crate supports an integration between Kyoto and <code>bdk_wallet</code>, so developers using <code>bdk_wallet</code> have a simple option to provide privacy-preserving and memory-conservative wallet syncing for their users.</p> <p>The following example uses the <code>bdk_kyoto</code> crate to recover and update a <code>bdk_wallet</code> using compact block filters.</p>","path":["Cookbook","Syncing","Sync a wallet with Kyoto"],"tags":[]},{"location":"cookbook/syncing/kyoto/#add-required-bdk-dependencies-to-your-cargotoml-file","level":3,"title":"Add required bdk dependencies to your <code>Cargo.toml</code> file","text":"Cargo.toml<pre><code>[package]\nname = \"kyoto\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nbdk_kyoto = \"0.15.1\"\nbdk_wallet = \"2\"\ntokio = { version = \"1\", features = [\"full\"], default-features = false }\ntracing = \"0.1\"\ntracing-subscriber = \"0.3\"\n</code></pre>","path":["Cookbook","Syncing","Sync a wallet with Kyoto"],"tags":[]},{"location":"cookbook/syncing/kyoto/#create-and-sync-the-wallet","level":3,"title":"Create and sync the wallet","text":"main.rs<pre><code>use bdk_kyoto::builder::{Builder, BuilderExt};\nuse bdk_kyoto::{\n    HeaderCheckpoint, Info, LightClient, Receiver, ScanType, UnboundedReceiver, Warning,\n};\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::{KeychainKind, Wallet};\nuse tokio::select;\n\nconst RECEIVE: &amp;str = \"tr([7d94197e/86'/1'/0']tpubDCyQVJj8KzjiQsFjmb3KwECVXPvMwvAxxZGCP9XmWSopmjW3bCV3wD7TgxrUhiGSueDS1MU5X1Vb1YjYcp8jitXc5fXfdC1z68hDDEyKRNr/0/*)\";\nconst CHANGE: &amp;str = \"tr([7d94197e/86'/1'/0']tpubDCyQVJj8KzjiQsFjmb3KwECVXPvMwvAxxZGCP9XmWSopmjW3bCV3wD7TgxrUhiGSueDS1MU5X1Vb1YjYcp8jitXc5fXfdC1z68hDDEyKRNr/1/*)\";\nconst RECOVERY_LOOKAHEAD: u32 = 50;\nconst NUM_CONNECTIONS: u8 = 1;\nconst NETWORK: Network = Network::Signet;\n\n/// Implement a custom logger that prints log messages to the console.\nasync fn trace_logs(mut info_rx: Receiver&lt;Info&gt;, mut warn_rx: UnboundedReceiver&lt;Warning&gt;) {\n    loop {\n        select! {\n            warn = warn_rx.recv() =&gt; {\n                if let Some(warn) = warn {\n                    tracing::warn!(\"{warn}\")\n                }\n            }\n            info = info_rx.recv() =&gt; {\n                if let Some(info) = info {\n                    tracing::info!(\"{info}\")\n                }\n            }\n        }\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    // Initialize tracing\n    let subscriber = tracing_subscriber::FmtSubscriber::new();\n    tracing::subscriber::set_global_default(subscriber).unwrap();\n\n    // Apply the recovery lookahead to the wallet\n    let mut wallet = Wallet::create(RECEIVE, CHANGE)\n        .network(NETWORK)\n        .lookahead(RECOVERY_LOOKAHEAD)\n        .create_wallet_no_persist()\n        .unwrap();\n\n    let scan_type = ScanType::Recovery {\n        used_script_index: RECOVERY_LOOKAHEAD,\n        checkpoint: HeaderCheckpoint::from_genesis(NETWORK),\n    };\n\n    // Build a node that will find and connect to peers, gather relevant blocks, and broadcast transactions.\n    // In addition, receive a client that allows for communication with a running node to receive wallet\n    // updates, relay transactions to the node, and get updates on the node's actions.\n    let LightClient {\n        requester,\n        info_subscriber,\n        warning_subscriber,\n        mut update_subscriber,\n        node,\n    } = Builder::new(NETWORK)\n        .required_peers(NUM_CONNECTIONS)\n        .build_with_wallet(&amp;wallet, scan_type)\n        .unwrap();\n\n    // Run the node on a separate task. The node will run continuously until instructed by the client\n    // to stop. The node will attempt to stay in sync with its peers by listening for messages as long\n    // as the application is running.\n    tokio::task::spawn(async move { node.run().await });\n\n    // Trace the logs with a custom function.\n    tokio::task::spawn(async move { trace_logs(info_subscriber, warning_subscriber).await });\n\n    // Sync and apply updates to the wallet. We can do this a continual loop while the application is running.\n    // Often this would occur on a separate thread than the underlying application user interface.\n    let update = update_subscriber.update().await.unwrap();\n    wallet.apply_update(update).unwrap();\n    tracing::info!(\"Tx count: {}\", wallet.transactions().count());\n    tracing::info!(\"Balance: {}\", wallet.balance().total().to_sat());\n    let last_revealed_external = wallet.derivation_index(KeychainKind::External).unwrap();\n    tracing::info!(\"Last revealed external: {}\", last_revealed_external);\n    tracing::info!(\"Local chain tip: {}\", wallet.local_chain().tip().height());\n    let next = wallet.peek_address(KeychainKind::External, last_revealed_external + 1);\n    tracing::info!(\"Next receiving address: {next}\");\n    requester.shutdown().unwrap();\n}\n</code></pre>","path":["Cookbook","Syncing","Sync a wallet with Kyoto"],"tags":[]},{"location":"cookbook/syncing/kyoto/#a-note-on-unconfirmed-transactions-recoveries-sync-and-full-scan","level":3,"title":"A note on unconfirmed transactions, recoveries, sync and full-scan","text":"<p>The entire set of scripts is checked against each block filter as new blocks are gossiped to the Kyoto node. Because the scripts are not checked iteratively, there is not a semantic difference between \"sync\" and \"full scan\". Rather, Kyoto is made aware of the <code>lookahead</code> number of scripts ahead of the last revealed index for each keychain in the wallet when the node is built. To recover a wallet, the <code>lookahead</code> should be set to a number greater than or equal to the number of scripts revealed by the wallet. Developers can and should add scripts to check for filter inclusions by calling <code>add_script</code> when transactions are built or addresses are revealed.</p> <p>Unconfirmed transactions pose a problem for light clients, as connections are untrusted. As such, users will be unaware of transactions they have received until they are confirmed in a block. While this tradeoff may be cumbersome, the benefits may outweigh the costs for privacy-conscious users.</p>","path":["Cookbook","Syncing","Sync a wallet with Kyoto"],"tags":[]},{"location":"cookbook/syncing/rpc/","level":1,"title":"Sync a Wallet with Bitcoin Core RPC","text":"","path":["Cookbook","Syncing","Sync a Wallet with Bitcoin Core RPC"],"tags":[]},{"location":"cookbook/syncing/rpc/#1-start-a-regtest-bitcoin-daemon","level":3,"title":"1. Start a regtest bitcoin daemon","text":"<p>For this example you'll need to run a bitcoin core daemon locally in regtest mode. Here are some of the commands you'll need: <pre><code># In a shell dedicated to the bitcoin daemon \nbitcoind --chain=regtest\n\n# In a new shell dedicated to the bitcoin-cli\nbitcoin-cli --chain=regtest getblockchaininfo\n\nbitcoin-cli --chain=regtest createwallet mywallet\nbitcoin-cli --chain=regtest loadwallet mywallet\nbitcoin-cli --chain=regtest getnewaddress\n\n# Mine 101 blocks\nbitcoin-cli --chain=regtest generatetoaddress 101 &lt;address&gt;\n\n# Send to address\nbitcoin-cli --chain=regtest sendtoaddress &lt;address&gt; &lt;amount&gt;\n</code></pre></p>","path":["Cookbook","Syncing","Sync a Wallet with Bitcoin Core RPC"],"tags":[]},{"location":"cookbook/syncing/rpc/#2-create-a-new-rust-project","level":3,"title":"2. Create a new Rust project","text":"<pre><code>cargo init rpcexample\ncd rpcexample\n</code></pre>","path":["Cookbook","Syncing","Sync a Wallet with Bitcoin Core RPC"],"tags":[]},{"location":"cookbook/syncing/rpc/#3-add-required-bdk-dependencies-to-your-cargotoml-file","level":3,"title":"3. Add required bdk dependencies to your <code>Cargo.toml</code> file","text":"Cargo.toml<pre><code>[package]\nname = \"rpc\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nbdk_wallet = { version = \"2.1.0\" }\nbdk_bitcoind_rpc = {  version = \"0.21.0\" }\n</code></pre>","path":["Cookbook","Syncing","Sync a Wallet with Bitcoin Core RPC"],"tags":[]},{"location":"cookbook/syncing/rpc/#4-create-your-descriptors","level":3,"title":"4. Create your descriptors","text":"<p>Refer to the Working with Descriptors page for information on how to generate descriptors. This page will assume you are working on Regtest with the following BIP86 descriptors: <pre><code>const EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/0/*)#g9xn7wf9\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/1/*)#e3rjrmea\";\n</code></pre></p>","path":["Cookbook","Syncing","Sync a Wallet with Bitcoin Core RPC"],"tags":[]},{"location":"cookbook/syncing/rpc/#5-create-and-sync-wallet","level":3,"title":"5. Create and sync wallet","text":"main.rs<pre><code>use std::sync::Arc;\n\nuse bdk_bitcoind_rpc::bitcoincore_rpc::{Auth, Client, RpcApi};\nuse bdk_bitcoind_rpc::{Emitter, NO_EXPECTED_MEMPOOL_TXS};\nuse bdk_wallet::bitcoin::{Network, Transaction};\nuse bdk_wallet::chain::local_chain::CheckPoint;\nuse bdk_wallet::{AddressInfo, Balance, KeychainKind, Wallet};\n\nconst COOKIE_FILE_PATH: &amp;str = \"&lt;path_to_your_regtest_bitcoin_core_data_dir&gt;/.cookie\";\nconst EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/0/*)#g9xn7wf9\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/1/*)#e3rjrmea\";\n\nfn main() {\n    let mut wallet: Wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n        .network(Network::Regtest)\n        .create_wallet_no_persist()\n        .unwrap();\n\n    let balance: Balance = wallet.balance();\n    println!(\"Wallet balance before syncing: {}\", balance.total());\n\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\n        \"Generated address {} at index {}\",\n        address.address, address.index\n    );\n\n    let rpc_client: Client = Client::new(\n        \"http://127.0.0.1:18443\",\n        // Auth::UserPass(\"__cookie__\".to_string(), \"cookievalue\".to_string())\n        Auth::CookieFile(COOKIE_FILE_PATH.into()),\n    )\n    .unwrap();\n\n    let blockchain_info = rpc_client.get_blockchain_info().unwrap();\n    println!(\n        \"\\nConnected to Bitcoin Core RPC.\\nChain: {}\\nLatest block: {} at height {}\\n\",\n        blockchain_info.chain, blockchain_info.best_block_hash, blockchain_info.blocks,\n    );\n\n    let wallet_tip: CheckPoint = wallet.latest_checkpoint();\n    println!(\n        \"Current wallet tip is: {} at height {}\",\n        &amp;wallet_tip.hash(),\n        &amp;wallet_tip.height()\n    );\n\n    let mut emitter = Emitter::new(\n        &amp;rpc_client,\n        wallet_tip.clone(),\n        wallet_tip.height(),\n        NO_EXPECTED_MEMPOOL_TXS,\n    );\n\n    println!(\"Syncing blocks...\");\n    while let Some(block) = emitter.next_block().unwrap() {\n        print!(\"{} \", block.block_height());\n        wallet\n            .apply_block_connected_to(&amp;block.block, block.block_height(), block.connected_to())\n            .unwrap();\n    }\n    println!();\n\n    println!(\"Syncing mempool...\");\n    let mempool_emissions: Vec&lt;(Arc&lt;Transaction&gt;, u64)&gt; = emitter.mempool().unwrap().update;\n    wallet.apply_unconfirmed_txs(mempool_emissions);\n\n    let balance: Balance = wallet.balance();\n    println!(\"Wallet balance after syncing: {}\", balance.total());\n}\n</code></pre> <p>Once you have synced the wallet once, mine a few new blocks using the bitcoin-cli and send coins to the address provided by the wallet and printed in the console. Upon running the example code again, your wallet will sync up the latest blocks and update its balance.</p>","path":["Cookbook","Syncing","Sync a Wallet with Bitcoin Core RPC"],"tags":[]},{"location":"cookbook/transactions/transaction-builder/","level":1,"title":"Transaction Builder","text":"<p>The Transaction Builder provides a convenient way to construct bitcoin transactions by offering a builder-type API that helps developers manage the typical requirements for building transactions: recipients, fees, signatures, and a whole lot more.</p>","path":["Cookbook","Transactions","Transaction Builder"],"tags":[]},{"location":"cookbook/transactions/transaction-builder/#features","level":2,"title":"Features","text":"<ul> <li>Flexible Input and Output Selection: You can add or subtract inputs and outputs as needed.</li> <li>Fees: The builder calculates and adds fees automatically based on a specified fee rate or absolute target.</li> <li>Finalization: The builder helps finalize the transaction, ensuring signatures and other conditions are met.</li> </ul>","path":["Cookbook","Transactions","Transaction Builder"],"tags":[]},{"location":"cookbook/transactions/transaction-builder/#usage","level":2,"title":"Usage","text":"<p>To start building a new transaction, instantiate the <code>TxBuilder</code> type provided by BDK by calling the <code>Wallet::build_tx()</code> method. On this builder you chain various methods to add inputs, outputs, and configure other settings. Finally, call <code>TxBuilder::finish()</code> to get a PSBT ready for signing.</p> <pre><code>let psbt = wallet.build_tx()\n    .add_recipient(address.script_pubkey(), amount)\n    .finish()?;\n</code></pre>","path":["Cookbook","Transactions","Transaction Builder"],"tags":[]},{"location":"cookbook/transactions/transaction-builder/#customizing-outputs","level":3,"title":"Customizing Outputs","text":"<p>You can specify multiple recipients for the transaction, distributing funds across various addresses. The output is added as a script with an amount:</p> <pre><code>wallet.build_tx()\n    .add_recipient(to_address1.script_pubkey(), amount1)\n    .add_recipient(to_address2.script_pubkey(), amount2)\n</code></pre>","path":["Cookbook","Transactions","Transaction Builder"],"tags":[]},{"location":"cookbook/transactions/transaction-builder/#choosing-inputs","level":3,"title":"Choosing Inputs","text":"<p>You can manually select specific UTXOs, as well as request to not spend specific UTXOs:</p> <pre><code>wallet.build_tx()\n    .add_utxo(utxo1)?\n    .add_unspendable(utxo2)\n    .add_recipient(address.script_pubkey(), amount)\n</code></pre> <p>Combining the above with <code>TxBuilder::manually_selected_only</code> will ensure that the wallet only spends UTXOs specified by the <code>TxBuilder::add_utxo</code> method.</p> <p>Alternatively, let the wallet choose the inputs:</p> <pre><code>wallet.build_tx()\n    .add_recipient(address.script_pubkey(), amount)\n</code></pre>","path":["Cookbook","Transactions","Transaction Builder"],"tags":[]},{"location":"cookbook/transactions/transaction-builder/#fee-management","level":3,"title":"Fee Management","text":"<p>The builder allows you to define a fee rate or an absolute fee:</p> <pre><code>wallet.build_tx()\n    .fee_rate(FeeRate::from_sat_per_vb(4))\n    .fee_absolute(Amount::from_sat(600))\n</code></pre> <p>Note that if you set the fee using both the fee_absolute and the fee_rate method, the wallet will use method was called last, as the fee rate and the absolute fee amount are mutually exclusive.</p>","path":["Cookbook","Transactions","Transaction Builder"],"tags":[]},{"location":"cookbook/transactions/transaction-builder/#spend-all-funds","level":3,"title":"Spend all funds","text":"<p>The transaction builder has a convenience method that will spend all UTXOs available to it (while respecting the unspendable UTXOs if any). Simple use of this method will simply increase the size of your change output, but you can combine it with the <code>TxBuilder::drain_to</code> method to ensure all funds are sent to a specific address:</p> <pre><code>let psbt = wallet.build_tx()\n    .drain_wallet()\n    .drain_to(address.script_pubkey());\n</code></pre>","path":["Cookbook","Transactions","Transaction Builder"],"tags":[]},{"location":"cookbook/transactions/transaction-builder/#set-the-nsequence-value","level":3,"title":"Set the nSequence value","text":"<p>The <code>TxBuilder::set_exact_sequence</code> method allows users to set their nSequence value directly. This is also the way you would disable signaling for RBF, as the TxBuilder will by default enable it.</p> <pre><code>wallet.build_tx()\n    .add_recipient(address.script_pubkey(), amount)\n    .set_exact_sequence(sequence)\n</code></pre>","path":["Cookbook","Transactions","Transaction Builder"],"tags":[]},{"location":"cookbook/transactions/transaction-builder/#finalizing-the-psbt","level":3,"title":"Finalizing the PSBT","text":"<p>Once youve added inputs, outputs, and calculated the fees, you can build the psbt using the <code>TxBuilder::finish</code> method.</p> <pre><code>let psbt = wallet.build_tx()\n    .finish()?;\n</code></pre> <p>The result is a PSBT ready to be signed and later on broadcast to the network.</p>","path":["Cookbook","Transactions","Transaction Builder"],"tags":[]},{"location":"cookbook/transactions/transaction-builder/#signing-the-psbt-and-extracting-the-transaction","level":2,"title":"Signing the PSBT and extracting the transaction","text":"<p>Sign the PSBT using the <code>Wallet::sign</code> method and extract the finalized transaction from it using the Psbt::extract_tx` method for a ready-to-be-broadcast transaction.</p> <pre><code>wallet.sign(&amp;mut psbt, SignOptions::default())?;\nlet tx = psbt.extract_tx()?;\n</code></pre>","path":["Cookbook","Transactions","Transaction Builder"],"tags":[]},{"location":"design/bindings/","level":1,"title":"Language Bindings","text":"<p>This article explores the reasons why the Bitcoin Dev Kit Foundation supports a number of language bindings libraries as part of its core offering, and the challenges and decision tradeoffs we face along the way.</p> <p>We build language bindings for a number of use cases. One of the most common of those rests on a belief that as time goes on, applications of all kinds will need to interact with the bitcoin protocol. Many of those will be applications that are not \"bitcoin-first\" like wallets, but rather other kinds of applications that simply wish to integrate payments for their users (games, chat applications, content creation, etc.). These applications already have well-developed codebases and teams, seldom built entirely in Rust (BDK's first and core language). Our goal is to offer these teams and applications an all-inclusive dependency they can add to whatever technology stack they are using in production, and allow the integration of bitcoin-related capabilities without the need to completely change their tech stack or require the hire of full-time bitcoin experts.</p> <p>Why not simply use libraries that are available in the specific languages? We think the Bitcoin Development Kit is special (of course we do!) for a few reasons: 1. The level of review and number of in-production applications in bitcoin that use the Rust bitcoin ecosystem of libraries is unparalleled (rust-bitcoin, rust-miniscript, and bdk, and so many more!). 2. For the reason above, it is most often the case that new features and BIPs are available in Rust first (taproot, miniscript, etc.) and take years to appear on other tech stacks.</p>","path":["Design","Language Bindings"],"tags":[]},{"location":"design/bindings/#awesome-producing-bindings-must-be-easy-right","level":2,"title":"Awesome! Producing Bindings Must Be Easy Right?","text":"<p>Along the way, actually producing language bindings for a variety of languages is no easy feat. Here are some of the challenges we face:</p> <ol> <li>We create bindings for many languages in one fell swoop with a Rust tool called uniffi. The result is that for the work of 1 language, we actually get many: Swift, Kotlin (works for JVM server-side and on Android), Java, Python, Flutter (Dart), and React Native (JS).</li> <li>The goal of the bindings is not to provide all the complexity available in the Rust libraries (this would simply be out-of-scope for us). We basically need to strike a balance and generate a unified API that contains and combines many Rust libraries: rust-bitcoin, rust-miniscript, bdk_wallet, bdk_chain, and the electrum, esplora, and kyoto client libraries. This is required because it is impractical to produce bindings libraries for all of the above individually. The final bindings libraries are centered around the bdk_wallet API, and supporting its most common use cases for mobile clients.</li> <li>Point 2 above has interesting implications: while developers using Rust can simply import any number of those libraries in their projects, we must expose as much (and as little) as is required.</li> <li>A few caveats give us interesting puzzles we need to juggle with as we design and develop the language bindings libraries:<ul> <li>We cannot expose Rust generics using uniffi. This means that in practice, we need to remove all generics from the Rust API (either by not exposing the underlying construct or by exposing allor the most importantof its variants as concrete types). In this process, some of the complexity and beauty of the Rust language and Rust-based codebases is \"erased\".</li> <li>Because the Rust code must be exposed in a variety of languages, some of the most Rust-specific syntax and features cannot be expressed in the bindings libraries. Things like functions that return tuples and tuple structs do not have Kotlin or Swift equivalents, and must therefore be wrapped in some way, changing the shape of the Rust API slightly.</li> </ul> </li> </ol>","path":["Design","Language Bindings"],"tags":[]},{"location":"design/bindings/#our-scope-and-approach-to-bindings","level":2,"title":"Our Scope and Approach to Bindings","text":"<p>We can't produce and maintain bindings for all Rust crates we get requests for, but we are working to help others build their own bindings by (1) making our architecture composable and reusable, and (2) building strong examples and documentation on how to do it for other crates.</p> <p>Over the past few years, the Bitcoin Development Kit team has been successful at building and releasing language bindings for our core Rust library, bdk_wallet. Over this time, we've had many requests to add to the bindings certain features that are not directly in the Rust BDK library. These requests mainly break down into two groups:</p> <ol> <li>Features that are part of crates \"upstream\" of BDK (rust-bitcoin, rust-miniscript)</li> <li>Features that are not, but that have Rust crates and would be useful on mobile (payjoin, coinjoin implementations, silent payments, BIP-47)</li> </ol>","path":["Design","Language Bindings"],"tags":[]},{"location":"design/bindings/#current-architecture","level":3,"title":"Current architecture","text":"<p>The current architecture for the BDK bindings is more or less wrapping the bdk, rust-bitcoin, and rust-miniscript crates and exposing an API that allows users to leverage them similarly to how they would in Rust if they were using it in a Rust project.</p> <p>While we started with a simplified version of the Rust BDK API, over time users asked for more and more functionality, and exposing some of the underlying rust-bitcoin constructs became important. This makes sense, and indeed users of the Bitcoin Development Kit in Rust have access to all the related APIs by simply importing rust-bitcoin and rust-miniscript, hence our desire to accommodate these use cases as well. However, this is currently done all in one \"bindings\" library (i.e. if you import <code>bdk-android</code> in a project, you'll have access to an API that is mostly bdk-based, but also contains a bit of rust-bitcoin and rust-miniscript).</p>","path":["Design","Language Bindings"],"tags":[]},{"location":"design/bindings/#moving-forward-building-a-family-of-libraries","level":3,"title":"Moving forward: building a family of libraries","text":"<p>At the same time, other Rust-based libraries are using the uniffi approach (a good example is ldk-node) to expose bindings. When developing and using those libraries together, it quickly became clear that much of the work was duplicated; both libraries needed access to underlying rust-bitcoin types, but they both exposed their own versions of it.</p> <p>The team is looking at extracting the rust-bitcoin part of the BDK bindings library (bdk-ffi) and publishing that library on crates.io so as to make it available to others who wish to build Rust bindings using uniffi. This is currently blocked upstream but might become available in future releases of uniffi.</p>","path":["Design","Language Bindings"],"tags":[]},{"location":"design/bindings/#why-cant-we-just-build-one-big-bdk-library-with-everything-in-it","level":3,"title":"Why can't we just build one big BDK library with everything in it?","text":"<ol> <li>The short answer to this is that it would simply not be maintainable. If we rely on many underlying Rust crates, we'd need to release patches every time one of the underlying libraries patches a bug. We'd also need to keep them all in sync (what API versions work with what), and we'd be relying on work from teams that may or may not have the capacity to keep their crates up to date.</li> <li>Scope creep. Unless we define a narrow and structured scope for the library, we will forever be handling requests for features that may or may not be feasible to accommodate.</li> <li>Library size. Because one of our primary focus for the bindings is mobile devices, we need to make sure we don't build a library that is too big. This is a more nuanced issue, but it relates to point (2), where too large a scope would eventually produce a library that is potentially not optimal for mobile devices because it attempts to do too much all in one package.</li> </ol>","path":["Design","Language Bindings"],"tags":[]},{"location":"design/bindings/#are-you-looking-to-build-rust-bindings-yourself","level":3,"title":"Are you looking to build Rust bindings yourself?","text":"<p>We got your back! The Bitcoin Development Kit team intends to help others in the Rust bitcoin ecosystem build bindings if they wish to. To that effect, we maintain repositories that should help you get going with bindings in no time:</p> <ol> <li>Uniffi library template. This is a repository you can fork and start adding code to produce bindings directly for iOS and Android. Included are our custom-made Gradle plugin and Swift release shell scripts, as well as information about the little build quirks you need to know about for smooth releases.</li> <li>Uniffi examples. This repository provides boiled-down examples of APIs exposed using uniffi, with an accompanying documentation website. Functions, enums, objects, callbacks, multi-libraries, a lot of information and examples to get you started.</li> </ol> <p>We also have a Discord server dedicated to uniffi-based libraries in bitcoin. Reach out on our standard Discord for an invite!</p>","path":["Design","Language Bindings"],"tags":[]},{"location":"design/cbf/","level":1,"title":"Compact Block Filters","text":"<p>In conversations with wallet developers, we've seen some common themes come up when it comes to compact block filters. Generally developers can quantify some of the properties of syncing wallets with compact block filters, but oftentimes the implementation details are fuzzy. With this article we are going to dive into the details, and share what to expect if you are considering block filters. Not all platforms, wallets and users would benefit from block filters, but our hope is to convince you, the developer, that both simple and private wallet syncing is possible for your app!</p>","path":["Design","Compact Block Filters"],"tags":[]},{"location":"design/cbf/#the-protocol","level":2,"title":"The Protocol","text":"<p>It's best to start with what it means to be a \"compact block filter client\". A compact block filter is a concise representation of what bitcoin scripts are in a block. These filters can be queried for a match against scripts that the user owns. Oftentimes these filters are only a few hundred bytes. A client is simply a program that downloads these filters for a particular range of blocks, queries them, and downloads the block in the case of a match.</p> <p>You may have a couple questions now: 1. Who is serving the filters? 2. How does the client know what filters to request?</p> <p>The answer to 1. is relatively simple. Any computer running a full-archival bitcoin node, like Bitcoin Core, can serve filters by selecting the configurations. That's it! The answer to 2. is a bit more interesting. The client must download the block headers from peers they connect to and decide what the chain of most proof of work is. Once the client has decided on a chain, the filters may be downloaded and queried.</p> <p>Notice</p> <p>Some steps are omitted for simplicity, however the primary actions for the client are: select a chain, download filters, download blocks</p> <p>This implies a few things. First, the client must communicate using the bitcoin peer-to-peer protocol, which is facilitated directly using TCP connections. This can be an advantage to your apps, as no HTTPS dependencies are required, reducing the binary size and potential for CVE vulnerabilities. Next, the client must store some information about chain, albeit not that much data. Third, the client must maintain a list and find peers to connect to, which we will dive into later.</p>","path":["Design","Compact Block Filters"],"tags":[]},{"location":"design/cbf/#why-do-all-of-this","level":2,"title":"Why do all of this?","text":"<p>A primary advantage of using block filters is user privacy. Requesting the block filters does not reveal any sensitive information, and bitcoin blocks are often full of many transactions. The client may also connect to multiple nodes and randomly select who to request blocks from. For users that have low resource devices, but would like strong privacy guarantees, block filters are the perfect option.</p> <p>The reliability of block filters is also dependent on the properties of the bitcoin network. If a reasonable amount of nodes are discover-able and serving filters, then the user experience is seamless and reliable. In contrast, using server-based protocols may incur rate-limiting and downtime. For users broadcasting transactions, this also implies they should never have to broadcast transactions to the same node twice, another great privacy win.</p> <p>On the experimental side, the block filter client is a \"pseudo-node\" itself. New types of wallets may run the client 24/7, and constantly sync the user's wallet with the chain. From the perspective of the user, their sync speed would be as fast as it takes to log-in to their dedicated server! My hope is block filters will invigorate self-hosting businesses and products for users to run their own infrastructure.</p>","path":["Design","Compact Block Filters"],"tags":[]},{"location":"design/cbf/#the-numbers","level":2,"title":"The Numbers","text":"<p>We've reviewed some of the properties, let's look at the metrics. We will begin with some on-device data, and transition into network-wide statistics.</p>","path":["Design","Compact Block Filters"],"tags":[]},{"location":"design/cbf/#storage","level":3,"title":"Storage","text":"<p>The impact on storage is minimal. At the time of writing, for the client to follow the chain of most work, roughly 0.072 gigabytes is required to store at a maximum. Most users will be using SegWit or Taproot, so this footprint should be more like 0.030 gigabytes. The book of addresses a client must maintain is configurable, but a reasonable list is only around 0.50 - 1.0 megabytes!</p>","path":["Design","Compact Block Filters"],"tags":[]},{"location":"design/cbf/#memory","level":3,"title":"Memory","text":"<p>The use of memory is also low. For syncing a month or two of data, the runtime overhead is around 30 to 40 megabytes, as measured on an iPhone. For recovering wallets, this may reach 70 to 80 megabytes, but this still doesn't come close to an application like YouTube.</p>","path":["Design","Compact Block Filters"],"tags":[]},{"location":"design/cbf/#bandwidth","level":3,"title":"Bandwidth","text":"<p>Bandwidth will fluctuate depending on how many transactions a user expects to send and receive. For a few months of data with a handful of transactions, the network usage should sit around 100 megabytes. However this may change for wallet recoveries. Users can expect to download up to a gigabyte or more for old wallets, so mobile users should be plugged into power and on WiFi for this step. After the initial recovery, users can sync while on the go! Usual syncs should be possible on cellular data in most regions.</p>","path":["Design","Compact Block Filters"],"tags":[]},{"location":"design/cbf/#energy-and-cpu-impact","level":3,"title":"Energy and CPU Impact","text":"<p>There are many hashing operations performed when syncing compact block filters, so the CPU usage tends to be higher than most consumer applications. While this is not a problem for short a duration, users that have not synced their wallet in 6 months or more should likely connect their phone to power. CPU usage may be cleverly spread out as well. If the underlying operating system allows it, scheduling a background sync with the OS when the user is likely to be connected to power will make the user experiences seamless, as their phone has stayed up-to-date with the chain.</p>","path":["Design","Compact Block Filters"],"tags":[]},{"location":"design/cbf/#time","level":3,"title":"Time","text":"<p>Sync times are highly variable, but on WiFi and with a fast per, a year of data can be synced in only a minute or two. Months of data may take 10-30 seconds, and a week should only take a moment. When network conditions are spotty, the numbers are harder to quantify. This is yet another reason to consider scheduling background tasks, as a daily sync should only take a second!</p>","path":["Design","Compact Block Filters"],"tags":[]},{"location":"design/cbf/#distribution-of-peers","level":3,"title":"Distribution of Peers","text":"<p>Developer Nick Johnson ran a census of what services bitcoin nodes are offering. Many nodes were polled - over 300,000 - however only around 11,000 were reachable. Of these, around 1,000 maintain a compact block filters index.</p> <p>On the one hand, having 1,000 potential peers is low considering how many bitcoin nodes exist. Yet that is also great from the client point of view, as the client essentially has 1,000 potential servers. The only problem is the client must poll these peers to find useful ones.</p> <p>A mitigation to polling a bunch of peers is using DNS seeders. These seeders are constantly crawling the bitcoin network and finding good peers, but relying solely on DNS implies a trust in the seeder. This is tricky for wallet developers and users, as they may want a fast syncing experience, but do not want to fully trust the seeder. A great option is to pick some peers from DNS for a sync, and others from the local address book.</p>","path":["Design","Compact Block Filters"],"tags":[]},{"location":"design/cbf/#challenges","level":2,"title":"Challenges","text":"<p>Now we turn to the design space to improve the user experience of light clients. I hope by now you are considering a block filter integration for your users, so here are the last couple caveats to consider.</p>","path":["Design","Compact Block Filters"],"tags":[]},{"location":"design/cbf/#unconfirmed-transactions","level":3,"title":"Unconfirmed Transactions","text":"<p>Many users come to expect an instant feedback when a transaction enters the server's memory pool in which they receive money. This is both a philosophical and technical problem, as current light clients cannot maintain a large memory pool, may not be online at the time of transaction gossip, and cannot validate transactions. Furthermore, even validated transactions may be changed via RBF, and the user may not receive the bitcoin they expect. If your users are advanced in their bitcoin knowledge, they should have at least a vague idea of why they will need to wait for a block.</p> <p>For users that are moving their bitcoin off the exchange for the first time, this wait-time may be confusing or scary. My first suggestion is still to wait for a block confirmation, but to inform the user they should check back in 10 minutes if they expect to receive a payment. Even if the exchange shows the transaction as sent, it should still remain \"pending\", so informative user interfaces are a potential solution to this problem.</p> <p>If that is still not enough, one could connect over the peer-to-peer network and monitor transaction gossip. I advice against this approach on mobile, as there is a non-zero, even high, probability the gossip messages are missed by the time the user opens their app. However, if your app is a self-hosted \"always on\" program, monitoring peer to peer gossip is far more acceptable, as gossip is being monitored even if the user is not logged in.</p>","path":["Design","Compact Block Filters"],"tags":[]},{"location":"design/cbf/#fee-estimation","level":3,"title":"Fee Estimation","text":"<p>Due to the construction of a bitcoin block, the amounts for each input cannot be known with simply the block data itself. One would need the transaction outputs corresponding to the outpoints contained in the block. This data is sometimes referred to as \"undo data\". Unfortunately, this means the light client cannot estimate fee rates for individual transactions in recent blocks.</p> <p>Servers are available to estimate fees, but this re-introduces HTTPs dependencies in the stack. If your use cases involves a small binary and strict dependency graph, there is still a solution to give fee rate approximation. The average fee rate paid in a block may be computed by taking <code>(Coinbase output - Block subidy) / Block Weight</code>. Averages are more effected by outliers, so exceptionally low or high fee rates on individual transactions may skew this number. Yet, it may be good enough for your users. </p> <p>This is an open area of research, and may be further improved with light weight machine learning models. However, if HTTPs is used in your app already, a server is recommended to fetch fees. As a final note, there are a mounting number of use cases for sending the \"undo data\" over the peer-to-peer network. If this feature is implemented, many aspects of the light client experience may be improved, including fee rate estimation.</p>","path":["Design","Compact Block Filters"],"tags":[]},{"location":"getting-started/3rd-party-bindings/","level":1,"title":"3rd Party Bindings","text":"<p>Some organizations are maintaining their own wrappers and language bindings around the BDK libraries. While these are not maintained by the Foundation, they have users in production and are worth looking into!</p>","path":["Getting Started","3rd Party Bindings"],"tags":[]},{"location":"getting-started/3rd-party-bindings/#wasm","level":2,"title":"WASM","text":"<p>bdk-wasm</p> <p>Note: The bdk-wasm lib can be used in just about any modern JavaScript environment, including Browser, Node, React Native, etc.</p>","path":["Getting Started","3rd Party Bindings"],"tags":[]},{"location":"getting-started/3rd-party-bindings/#flutter","level":2,"title":"Flutter","text":"<p>bdk-flutter</p>","path":["Getting Started","3rd Party Bindings"],"tags":[]},{"location":"getting-started/3rd-party-bindings/#react-native","level":2,"title":"React Native","text":"<p>bdk-rn</p> <p>Note: the <code>bdk-wasm</code> lib also works for React Native.</p>","path":["Getting Started","3rd Party Bindings"],"tags":[]},{"location":"getting-started/about/","level":1,"title":"About The Bitcoin Development Kit","text":"<p>The Bitcoin Development Kit (BDK) project was created to provide well engineered and reviewed components for building bitcoin-based applications.</p> <p>The core components of BDK are written in the Rust language and live in the <code>bitcoindevkit</code> GitHub org. The core BDK components are built upon the excellent <code>rust-bitcoin</code> and <code>rust-miniscript</code> crates.</p> <p>The BDK team also maintains the <code>bitcoindevkit/bdk-ffi</code> repository which provide cross-platform versions of the high level BDK APIs. Platforms currently supported by the BDK team include: Kotlin (Android, Linux, macOS), Swift (iOS, macOS), and Python (Linux, macOS, Windows). There are also various 3rd party supported bindings for other languages, including Flutter, React Native, and JavaScript (WASM bindings for Browser/Node/React Native).</p>","path":["Getting Started","About The Bitcoin Development Kit"],"tags":[]},{"location":"getting-started/api-documentation/","level":1,"title":"API Documentation","text":"<p>Our API documentation is available here:</p> <ul> <li>bdk_wallet</li> <li>bdk_chain</li> <li>bdk_file_store</li> <li>bdk_electrum</li> <li>bdk_esplora</li> <li>bdk_bitcoind_rpc</li> <li>bdk_hwi</li> <li>esplora-client</li> <li>electrum-client</li> </ul> <ul> <li>Kotlin</li> <li>Python</li> </ul>","path":["Getting Started","API Documentation"],"tags":[]},{"location":"getting-started/bdk-cli/","level":1,"title":"The BDK Command Line Wallet","text":"","path":["Getting Started","The BDK Command Line Wallet"],"tags":[]},{"location":"getting-started/bdk-cli/#purpose","level":2,"title":"Purpose","text":"<p>The <code>bdk-cli</code> binary crate is designed as an experimental playground for users to dive into the <code>BDK</code> libraries with ease. </p> <p>Its documentation is available here, and you can explore the source code here.</p>","path":["Getting Started","The BDK Command Line Wallet"],"tags":[]},{"location":"getting-started/bdk-cli/#features","level":2,"title":"Features","text":"<p><code>bdk-cli</code> can be compiled with different features to suit your experimental needs.</p>","path":["Getting Started","The BDK Command Line Wallet"],"tags":[]},{"location":"getting-started/bdk-cli/#1-database-options","level":4,"title":"1. Database Options","text":"<ul> <li><code>sqlite</code>: Sets the wallet database to a sqlite3 db. <code>sqlite</code> is a default feature.</li> </ul>","path":["Getting Started","The BDK Command Line Wallet"],"tags":[]},{"location":"getting-started/bdk-cli/#2-blockchain-options","level":4,"title":"2. Blockchain Options","text":"<ul> <li><code>rpc</code>: Connects the wallet to bitcoin core via RPC.</li> <li><code>electrum</code>: Connects the wallet to an electrum server.</li> <li><code>esplora</code>: Connects the wallet to an esplora server.</li> <li><code>cbf</code>: Connects the wallet to kyoto - a node and client for compact block filter based syncing.</li> </ul>","path":["Getting Started","The BDK Command Line Wallet"],"tags":[]},{"location":"getting-started/bdk-cli/#3-extra-utility-tools","level":4,"title":"3. Extra Utility Tools","text":"<ul> <li><code>repl</code>: use bdk-cli as a REPL shell (useful for quick manual testing of wallet operations). <code>repl</code> is also a default feature.</li> <li><code>compiler</code>: opens up bdk-cli policy compiler commands.</li> <li><code>verify</code>: uses bitcoinconsensus to verify transactions at every sync call of the wallet.</li> </ul> <p>These features are non-exhaustive as more features will be added.</p>","path":["Getting Started","The BDK Command Line Wallet"],"tags":[]},{"location":"getting-started/bdk-cli/#installation","level":2,"title":"Installation","text":"<p>You have the option to build <code>bdk-cli</code> from its source code or install directly from <code>crates.io</code>.</p> <p>To build from the source:</p> <pre><code>git clone git@github.com:bitcoindevkit/bdk-cli.git\ncd bdk-cli/\ncargo install --path . --features electrum\nbdk-cli help # to verify it worked\n</code></pre> <p>To install from <code>crates.io</code>, run this command:</p> <pre><code>cargo install bdk-cli --features electrum  # add any additional features as needed\n</code></pre> <p>Note that if no blockchain client feature is enabled, online wallet commands will be disabled.</p>","path":["Getting Started","The BDK Command Line Wallet"],"tags":[]},{"location":"getting-started/bdk-cli/#usage","level":2,"title":"Usage","text":"<p>To get usage information for the bdk-cli binary use the below command which returns a list of available wallet options and commands:</p> <pre><code>cargo run\n</code></pre> <p>Follow the instruction in descriptors to generate descriptors, selecting your preferred network and descriptor type.</p> <p>Assuming you exported your external and internal descriptors as <code>EXT_DESC</code> and <code>INT_DESC</code>, we can generate a new address by running the following command:</p> <pre><code>cargo run -- --network &lt;selectednetwork&gt; wallet -e $EXT_DESC -i $INT_DESC -d sqlite new_address\n</code></pre> <p>To sync the above wallet to a Bitcoin Core node (assuming a regtest node at 127.0.0.1:18443, username and password of bitcoin:bitcoin), run the following command:</p> <pre><code>cargo run --features rpc wallet -e $EXT_DESC -i $INT_DESC -d sqlite -c rpc -u 127.0.0.1:18443 -a bitcoin:bitcoin sync\n</code></pre>","path":["Getting Started","The BDK Command Line Wallet"],"tags":[]},{"location":"getting-started/migrating/","level":1,"title":"Migrating from 0.X","text":"<p>So you're ready to migrate to BDK version 1.0, congratulations! This document contains some helpful tips that, with the help of some automation, should make the process as seamless as possible.</p> <p>The below steps are for migrating wallet details from the old <code>bdk</code> v0.30 to the new <code>bdk_wallet</code> v1.0. This procedure can be applied to wallets backed by a SQLite database.</p> <p>To migrate your wallet data to a new version of bdk, essentially all you need to do is grab the last known address index for each keychain from the old db, add them to the new db, and sync to refetch the rest of the data. Doing this means we don't need to perform a full scan because we already have the indexes (doing a full scan would check for used addresses based on the stop gap which is unnecessary).</p> <p>This migration is important because without that metadata the new wallet may end up reusing receive addresses, which should be avoided for privacy reasons.</p> <p>Note</p> <p>The migration process outlined below will not automatically restore the wallet's transaction data or local view of the blockchain. Thanks to the public ledger however, we can restore all the pertinent information for this wallet using one of the blockchain client libraries supported by BDK.</p>","path":["Getting Started","Migrating from 0.X"],"tags":[]},{"location":"getting-started/migrating/#overview","level":2,"title":"Overview","text":"<ol> <li>Load an old database</li> <li>Get last revealed addresses</li> <li>Create new wallet</li> <li>Restore revealed addresses</li> <li>Write to new database</li> <li>Sync</li> </ol> examples/rust/migrate-version/src/main.rs<pre><code>fn main() -&gt; anyhow::Result&lt;()&gt; {\n    // Open old wallet\n    let db = SqliteDatabase::new(BDK_DB_PATH);\n    let old_wallet = bdk::Wallet::new(\n        EXTERNAL_DESCRIPTOR,\n        Some(INTERNAL_DESCRIPTOR),\n        bdk::bitcoin::Network::Testnet,\n        db,\n    )?;\n\n    // Get last revealed addresses for each keychain\n    let addr = old_wallet.get_address(AddressIndex::LastUnused)?;\n    println!(\"Last revealed external {} {}\", addr.index, addr.address);\n    let external_derivation_index = addr.index;\n    let last_revealed_external = addr.address.to_string();\n\n    let addr = old_wallet.get_internal_address(AddressIndex::LastUnused)?;\n    println!(\"Last revealed internal {} {}\", addr.index, addr.address);\n    let internal_derivation_index = addr.index;\n    let last_revealed_internal = addr.address.to_string();\n\n    // Create new wallet\n    let mut db = rusqlite::Connection::open(BDK_WALLET_DB_PATH)?;\n    let mut new_wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n        .network(NETWORK)\n        .create_wallet(&amp;mut db)\n        .context(\"failed to create wallet\")?;\n\n    // Retore revealed addresses\n    let _ = new_wallet.reveal_addresses_to(KeychainKind::External, external_derivation_index);\n    let _ = new_wallet.reveal_addresses_to(KeychainKind::Internal, internal_derivation_index);\n\n    // Persist new wallet\n    new_wallet.persist(&amp;mut db)?;\n\n    println!(\"\\n========== New database created. ==========\");\n\n    let addr = new_wallet\n        .list_unused_addresses(KeychainKind::External)\n        .last()\n        .unwrap();\n    assert_eq!(addr.to_string(), last_revealed_external);\n    println!(\"Last revealed external {} {}\", addr.index, addr.address);\n    let addr = new_wallet\n        .list_unused_addresses(KeychainKind::Internal)\n        .last()\n        .unwrap();\n    println!(\"Last revealed internal {} {}\", addr.index, addr.address);\n    assert_eq!(addr.to_string(), last_revealed_internal);\n\n    Ok(())\n}\n</code></pre>","path":["Getting Started","Migrating from 0.X"],"tags":[]},{"location":"getting-started/migrating/#walkthrough","level":2,"title":"Walkthrough","text":"<p>In a new Rust project add these dependencies to <code>Cargo.toml</code></p> Cargo.toml<pre><code>[dependencies]\nanyhow = \"1\"\nbdk = { version = \"0.30\", features = [\"sqlite\"] }\nbdk_wallet = { version = \"1.0.0\", features = [\"rusqlite\"] }\n</code></pre> <p>Because there are two versions of bdk in the same project, we need to pay attention to how types are imported.</p> <p>To avoid name clashes or any sort of mismatch resolving types that appear similar, we use fully qualified syntax, for example <code>bdk::bitcoin::Network::Testnet</code>. You'll notice in some cases we can get around this annoyance by casting a value to another rust primitive or standard library type such as <code>String</code>.</p> examples/rust/migrate-version/src/main.rs<pre><code>use anyhow::Context;\n\nuse bdk::database::SqliteDatabase;\nuse bdk::wallet::AddressIndex;\n\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::rusqlite;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::Wallet;\n</code></pre> <p>Take a minute to define a few constants, for example the file path to the current database and the path to be used for the new database. The descriptors and network shown here are for illustration; you should substitute them with your own. Note that because we'll be creating a fresh database there should not already exist a persisted wallet at the new path.</p> examples/rust/migrate-version/src/main.rs<pre><code>const EXTERNAL_DESCRIPTOR: &amp;str = \"wpkh(tprv8ZgxMBicQKsPdy6LMhUtFHAgpocR8GC6QmwMSFpZs7h6Eziw3SpThFfczTDh5rW2krkqffa11UpX3XkeTTB2FvzZKWXqPY54Y6Rq4AQ5R8L/84'/1'/0'/0/*)\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"wpkh(tprv8ZgxMBicQKsPdy6LMhUtFHAgpocR8GC6QmwMSFpZs7h6Eziw3SpThFfczTDh5rW2krkqffa11UpX3XkeTTB2FvzZKWXqPY54Y6Rq4AQ5R8L/84'/1'/0'/1/*)\";\nconst NETWORK: Network = Network::Testnet;\n\n// path to old db\nconst BDK_DB_PATH: &amp;str = \"./.bdk-example.sqlite\";\n// path to new db\nconst BDK_WALLET_DB_PATH: &amp;str = \"./.bdk-wallet-example.sqlite\";\n</code></pre> <p>Now retrieve the last revealed addresses from the <code>old_wallet</code>.</p> examples/rust/migrate-version/src/main.rs<pre><code>// Open old wallet\nlet db = SqliteDatabase::new(BDK_DB_PATH);\nlet old_wallet = bdk::Wallet::new(\n    EXTERNAL_DESCRIPTOR,\n    Some(INTERNAL_DESCRIPTOR),\n    bdk::bitcoin::Network::Testnet,\n    db,\n)?;\n\n// Get last revealed addresses for each keychain\nlet addr = old_wallet.get_address(AddressIndex::LastUnused)?;\nprintln!(\"Last revealed external {} {}\", addr.index, addr.address);\nlet external_derivation_index = addr.index;\nlet last_revealed_external = addr.address.to_string();\n\nlet addr = old_wallet.get_internal_address(AddressIndex::LastUnused)?;\nprintln!(\"Last revealed internal {} {}\", addr.index, addr.address);\nlet internal_derivation_index = addr.index;\nlet last_revealed_internal = addr.address.to_string();\n</code></pre> <p>For the <code>new_wallet</code> we should be using the same descriptors and network as before. If the given descriptors contain secret keys, then the wallet will be able to sign transactions as well.</p> examples/rust/migrate-version/src/main.rs<pre><code>// Create new wallet\nlet mut db = rusqlite::Connection::open(BDK_WALLET_DB_PATH)?;\nlet mut new_wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n    .network(NETWORK)\n    .create_wallet(&amp;mut db)\n    .context(\"failed to create wallet\")?;\n\n// Retore revealed addresses\nlet _ = new_wallet.reveal_addresses_to(KeychainKind::External, external_derivation_index);\nlet _ = new_wallet.reveal_addresses_to(KeychainKind::Internal, internal_derivation_index);\n\n// Persist new wallet\nnew_wallet.persist(&amp;mut db)?;\n\nprintln!(\"\\n========== New database created. ==========\");\n\nlet addr = new_wallet\n    .list_unused_addresses(KeychainKind::External)\n    .last()\n    .unwrap();\nassert_eq!(addr.to_string(), last_revealed_external);\nprintln!(\"Last revealed external {} {}\", addr.index, addr.address);\nlet addr = new_wallet\n    .list_unused_addresses(KeychainKind::Internal)\n    .last()\n    .unwrap();\nprintln!(\"Last revealed internal {} {}\", addr.index, addr.address);\nassert_eq!(addr.to_string(), last_revealed_internal);\n</code></pre> <p>Now that we have a new database and have properly restored our addresses, you will want to sync with the blockchain to recover the wallet's transactions. Below is an example of doing a <code>sync</code> using <code>bdk_esplora</code> but the exact method of syncing will depend on your application. Remember we don't need to do a full scan here since we already have the indexes.</p> examples/rust/migrate-version/src/main.rs<pre><code>use bdk_esplora::{esplora_client, EsploraExt};\n\nlet client = esplora_client::Builder::new(ESPLORA_URL).build_blocking();\n\nlet request = wallet\n    .start_sync_with_revealed_spks()\n    .inspect(|item, prog| {\n        if let SyncItem::Spk(index, script) = item {\n            let address = Address::from_script(script, NETWORK).unwrap();\n            let progress = prog.consumed() as f32 / prog.total() as f32;\n            eprintln!(\"[ SYNCING {:.2}% ] {:?} {}\", 100.0 * progress, index, address);\n            std::io::stdout().flush().unwrap();\n        }\n    });\n\nlet update = client.sync(request, PARALLEL_REQUESTS)?;\n\nwallet.apply_update(update)?;\nwallet.persist(&amp;mut db)?;\n</code></pre> <p>Happy migrating and see you on v1.0!</p>","path":["Getting Started","Migrating from 0.X"],"tags":[]},{"location":"getting-started/more/","level":1,"title":"More Places to Find BDK Content","text":"<p>Here are some other places you can find BDK-related content:</p>","path":["Getting Started","More Places to Find BDK Content"],"tags":[]},{"location":"getting-started/more/#youtube","level":2,"title":"Youtube","text":"<ul> <li>We have our own YouTube channel!</li> <li>Check out the BDK Tech Talks series for in-depth talks about BDK.</li> <li>Building on bitcoin with the Bitcoin Development Kit (BitDevsLA)</li> <li>The Bitcoin Developers channel has a series of videos on BDK.</li> <li>Building on BDK with Ben Carman, Alekos Filini &amp; Steve Myers</li> <li>Using the Bitcoin Development Kit and Wallet Descriptors for Taproot</li> <li>User Research on FOSS bitcoin project: Bitcoin Dev Kit</li> <li>Building wallets with Rust using Bitcoin (basic tutorial series)</li> <li>Magical Bitcoin (now BDK) presentation by Alekos Filini (BitDevsLA) </li> </ul>","path":["Getting Started","More Places to Find BDK Content"],"tags":[]},{"location":"getting-started/more/#podcasts","level":2,"title":"Podcasts","text":"<ul> <li>Alekos and Daniela on the Chaincode Podcast</li> </ul>","path":["Getting Started","More Places to Find BDK Content"],"tags":[]},{"location":"getting-started/more/#awesome-list","level":2,"title":"Awesome List","text":"<ul> <li>We maintain an Awesome List for BDK.</li> </ul>","path":["Getting Started","More Places to Find BDK Content"],"tags":[]},{"location":"getting-started/organization/","level":1,"title":"Project Organization","text":"<p>Within the <code>bitcoindevkit</code> GitHub organization, the BDK team maintains a suite of Rust crates which provide both easy-to-use high level APIs and powerful lower level components to use when building more advanced bitcoin software.</p>","path":["Getting Started","Project Organization"],"tags":[]},{"location":"getting-started/organization/#source-code","level":2,"title":"Source Code","text":"<p>The core project is split up into several crates:</p> <ul> <li><code>bdk_wallet</code>: Contains the central high level <code>Wallet</code> type    that is built from the low-level mechanisms provided by the other components.</li> <li><code>bdk_chain</code>: Tools for storing and indexing chain data.</li> <li><code>bdk_sqlite</code>: A simple SQLite relational database client for persisting bdk_chain data.</li> <li><code>bdk_esplora</code>: Extends the <code>esplora-client</code>    crate with methods to fetch chain data from an esplora HTTP server in the form that    <code>bdk_chain</code> and <code>Wallet</code> can consume.</li> <li><code>bdk_electrum</code>: Extends the <code>electrum-client</code>    crate with methods to fetch chain data from an electrum server in the form that    <code>bdk_chain</code> and <code>Wallet</code> can consume.</li> <li><code>bdk_bitcoind_rpc</code>: For extracting and emitting blockchain data from <code>bitcoind</code> RPC interface.</li> <li><code>bdk-ffi</code>: The wrapper library that exposes the Rust APIs to our target language bindings through uniffi.</li> </ul>","path":["Getting Started","Project Organization"],"tags":[]},{"location":"getting-started/tiers/","level":1,"title":"Library Tiers","text":"<p>We provide the technical infrastructure to maintain a number of software projects across different maturity levels and support models. To help you navigate these projects we've categorized them along two dimensions: Maturity Level (Stable vs Experimental) and Support Model (Foundation vs Community). </p>","path":["Getting Started","Library Tiers"],"tags":[]},{"location":"getting-started/tiers/#library-categories","level":2,"title":"Library Categories","text":"<p>We categorize our libraries along two dimensions to help you understand what level of support and stability to expect:</p> Foundation Community Stable Core BDK libraries with comprehensive support Well-maintained libraries for specific use cases Experimental Foundation projects under active development Community-driven experimental projects <p>Maturity Level: </p> <ul> <li>Stable: Production-ready libraries with stable APIs, comprehensive testing, and backward compatibility guarantees. </li> <li>Experimental: Early-stage projects with evolving APIs, basic testing, and potential for major changes. </li> </ul> <p>Support Model:</p> <ul> <li>Foundation: Libraries receiving direct support and grant funding from the BDK Foundation. </li> <li>Community: Libraries maintained primarily by volunteer contributors from the community. </li> </ul> <p></p>","path":["Getting Started","Library Tiers"],"tags":[]},{"location":"getting-started/tiers/#what-to-expect","level":2,"title":"What to expect","text":"","path":["Getting Started","Library Tiers"],"tags":[]},{"location":"getting-started/tiers/#stable-foundation","level":3,"title":"Stable + Foundation","text":"<p>The core of the BDK ecosystem. Production-ready libraries that receive the highest level of attention and maintenance.</p> <p>What to expect:</p> <ul> <li>Two official maintainers supported by grant funding from the BDK Foundation</li> <li>A robust community of users and volunteer maintainers</li> <li>Comprehensive test coverage and CI/CD</li> <li>Security updates and dependency maintenance</li> <li>Security updates back ported to prior major release</li> <li>Active monitoring and fast response to issues</li> <li>Semantic versioning with clear release notes</li> <li>Data schema stability guarantees and clear migration paths</li> <li>Extensive documentation (API, tutorials, guides, etc.) with code examples</li> <li>Example applications</li> </ul>","path":["Getting Started","Library Tiers"],"tags":[]},{"location":"getting-started/tiers/#stable-community","level":3,"title":"Stable + Community","text":"<p>Well-maintained, production-ready libraries serving more specific use cases. These rely more on community contributions for maintenance.</p> <p>What to expect:</p> <ul> <li>Two official maintainers (volunteers from the community)</li> <li>Maintainers may receive grant funding from the BDK Foundation</li> <li>A robust community of users and volunteer maintainers</li> <li>Comprehensive test coverage and CI/CD</li> <li>Security updates and dependency maintenance</li> <li>Semantic versioning with clear release notes</li> <li>Response to issues within a reasonable timeframe</li> <li>Documentation (API) with code examples</li> </ul>","path":["Getting Started","Library Tiers"],"tags":[]},{"location":"getting-started/tiers/#experimental-foundation","level":3,"title":"Experimental + Foundation","text":"<p>Early-stage Foundation projects undergoing active development with Foundation support.</p> <p>What to expect:</p> <ul> <li>At least one official maintainer supported by grant funding</li> <li>Incomplete or evolving APIs</li> <li>Basic test coverage and CI/CD</li> <li>Limited backward compatibility guarantees</li> <li>Minimal documentation</li> <li>Potential for major changes as the project matures</li> <li>Clear path toward becoming Stable + Foundation</li> </ul>","path":["Getting Started","Library Tiers"],"tags":[]},{"location":"getting-started/tiers/#experimental-community","level":3,"title":"Experimental + Community","text":"<p>Community-driven experimental projects exploring new ideas or serving niche use cases.</p> <p>What to expect:</p> <ul> <li>At least one official maintainer (volunteer from the community)</li> <li>Incomplete or evolving APIs</li> <li>Only basic test coverage and CI/CD</li> <li>Limited or no backward compatibility guarantees</li> <li>Minimal documentation</li> <li>Potential for major changes or deprecation</li> </ul>","path":["Getting Started","Library Tiers"],"tags":[]},{"location":"getting-started/tiers/#detailed-comparison-table","level":2,"title":"Detailed Comparison Table","text":"Stable +Foundation Stable +Community Experimental +Foundation Experimental +Community Maintainers 2 2 1+ 1+ BDKF Grant Funding Yes Optional Yes No Community Support Possible Yes Possible Yes Comprehensive Testing &amp; CI/CD Yes Yes Basic Basic Security &amp; Dependency Updates Yes Yes Yes Limited Semantic Versioning Yes Yes Yes Yes Back-ported Security Updates Yes No No No Fast Response to Issues Yes Reasonable Variable Variable API Stability Yes Yes No No API Documentation &amp; Examples Extensive Yes Minimal Minimal Tutorials &amp; Guides Yes No No No Example Applications Yes No No No","path":["Getting Started","Library Tiers"],"tags":[]},{"location":"getting-started/tiers/#where-to-find-this-information","level":2,"title":"Where to Find This Information","text":"<p>You can find the categories assigned to each library in our GitHub Org under the Libraries heading. There you'll also find information on the specific maintainers assigned to each library.</p>","path":["Getting Started","Library Tiers"],"tags":[]},{"location":"getting-started/why-book/","level":1,"title":"Who Is This Book For?","text":"<p>The purpose of this book is to give a strong overview of the Bitcoin Development Kit family of libraries and how they can be used together to build production-grade bitcoin applications. We aim to provide a good understanding of how to leverage our libraries together, expose the options available to developers in terms of blockchain clients and persistence layers.</p> <p>Finally, the book is meant to get developers up to speed on general concepts pertaining to the BDK architecture as well as concrete examples of how to use our APIs in the different languages for which we provide language bindings libraries.</p>","path":["Getting Started","Who Is This Book For?"],"tags":[]},{"location":"getting-started/why-book/#what-this-book-is-not","level":3,"title":"What this book is not","text":"<ul> <li>API documentation, nor a comprehensive listing of all APIs available in BDK libraries. We maintain API docs on all our libraries for that purpose.</li> <li>A place to learn about core bitcoin concepts (PSBTs, UTXOs, Electrum protocol, BIPs, etc.). We provide links to great resources on these topics where appropriate.</li> <li>A comprehensive treatment of the tradeoff space developers face when building bitcoin applications (Esplora protocol vs compact block filters, onchain vs layer 2s, secure elements on mobile devices, etc.).</li> </ul>","path":["Getting Started","Who Is This Book For?"],"tags":[]},{"location":"release-guide/guide/","level":1,"title":"About","text":"<p>The BDK Release Guide provides detailed documentation for major BDK releases, helping developers understand new features, breaking changes, and migration paths as the library evolves.</p>","path":["Release Guide","About"],"tags":[]},{"location":"release-guide/guide/#whats-inside","level":2,"title":"What's Inside","text":"<p>Each release section contains:</p> <ul> <li>Release Notes: High-level overview of changes, including release dates and links to the full changelog</li> <li>Feature Guides: In-depth explanations of major new features, with code examples and practical usage patterns</li> <li>Migration Information: Guidance on breaking changes and how to update your code</li> </ul>","path":["Release Guide","About"],"tags":[]},{"location":"release-guide/2.1/multipath/","level":1,"title":"Wallet Support For Public Multipath Descriptors","text":"<p>Overview</p> <ul> <li>Lead Developer: @schjonhaug</li> <li>Ticket: #11</li> <li>Pull Request: #275</li> <li>Feature Type: Non-breaking</li> </ul>","path":["Release Guide","Release 2.1","Wallet Support For Public Multipath Descriptors"],"tags":[]},{"location":"release-guide/2.1/multipath/#overview","level":2,"title":"Overview","text":"<ul> <li>We add a new API, <code>Wallet::create_multipath(descriptor)</code> following the same pattern as <code>create()</code> and <code>create_single()</code>.</li> <li>BIP 389 compliance with exactly 2-path validation (receive and change).</li> <li>The multipath descriptor must be a public descriptor.</li> </ul> Example<pre><code>let multipath_desc = \"wpkh([9a6a2580/84'/1'/0']tpubabcde.../0;1/*)\";\nlet wallet = Wallet::create_multipath(multipath_desc)\n      .network(Network::Testnet)\n      .create_wallet_no_persist()?;\n\n// Automatically creates separate receive and change descriptors\nlet receive_address = wallet.peek_address(KeychainKind::External, 0);  // Uses path /0/*\nlet change_address = wallet.peek_address(KeychainKind::Internal, 0);   // Uses path /1/*\n</code></pre>","path":["Release Guide","Release 2.1","Wallet Support For Public Multipath Descriptors"],"tags":[]},{"location":"release-guide/2.1/multipath/#why-do-this","level":2,"title":"Why Do This?","text":"<p>Multipath descriptors are fairly common nowadays, and there was a lot of demand for supporting a constructor on the wallet that would handle them gracefully.</p>","path":["Release Guide","Release 2.1","Wallet Support For Public Multipath Descriptors"],"tags":[]},{"location":"release-guide/2.1/multipath/#notes","level":2,"title":"Notes","text":"<ul> <li>The constructor only allows exactly 2-path multipath descriptors to ensure proper receive/change separation.</li> </ul>","path":["Release Guide","Release 2.1","Wallet Support For Public Multipath Descriptors"],"tags":[]},{"location":"release-guide/2.1/notes/","level":1,"title":"2.1 Release Notes","text":"<p>Overview</p> <ul> <li>Release Date: August 6, 2025</li> <li>Changelog: Link </li> </ul>","path":["Release Guide","Release 2.1","2.1 Release Notes"],"tags":[]},{"location":"release-guide/2.1/notes/#notable-changes","level":2,"title":"Notable Changes","text":"<ul> <li>The transaction builder adds 2 new methods: <code>TxBuilder::exclude_unconfirmed</code> and <code>TxBuilder::exclude_below_confirmations</code>. See details here.</li> <li>Wallets can now be created using public multipath descriptors. See details here.</li> </ul>","path":["Release Guide","Release 2.1","2.1 Release Notes"],"tags":[]},{"location":"release-guide/2.1/txbuilder-exclude/","level":1,"title":"Exclude Inputs Based On Maturity When Building Transactions","text":"<p>Overview</p> <ul> <li>Lead Developer: @evanlinjin</li> <li>Ticket: #143</li> <li>Pull Request: #258</li> <li>Feature Type: Non-breaking</li> </ul>","path":["Release Guide","Release 2.1","Exclude Inputs Based On Maturity When Building Transactions"],"tags":[]},{"location":"release-guide/2.1/txbuilder-exclude/#overview","level":2,"title":"Overview","text":"<ul> <li>Two methods are added to the TxBuilder, allowing users to exclude inputs that are either (a) unconfirmed, or (b) below a certain confirmation threshold.</li> </ul> Example 1<pre><code>let mut builder = wallet.build_tx();\nbuilder\n    .fee_rate(FeeRate::ZERO)\n    .add_recipient(recipient_address.script_pubkey(), Amount::from_sat(50_000))\n    .exclude_unconfirmed();\nlet tx = builder.finish().unwrap();\n</code></pre> Example 2<pre><code>let mut builder = wallet.build_tx();\nbuilder\n    .fee_rate(FeeRate::ZERO)\n    .add_recipient(recipient_address.script_pubkey(), Amount::from_sat(50_000))\n    .exclude_below_confirmations(6);\nlet tx = builder.finish().unwrap();\n</code></pre>","path":["Release Guide","Release 2.1","Exclude Inputs Based On Maturity When Building Transactions"],"tags":[]},{"location":"release-guide/2.1/txbuilder-exclude/#why-do-this","level":2,"title":"Why Do This?","text":"<p>These are convenience methods that fit a broad number of use cases. Previously, users had to do custom UTXO selection if they needed to ensure they used inputs that were confirmed onchain, or had a certain number of confirmations. This allows users to keep the BDK coins selection algos working their magic while also refraining from picking inputs that are not yet confirmed or within a specific confirmation threshold.</p> <p></p>","path":["Release Guide","Release 2.1","Exclude Inputs Based On Maturity When Building Transactions"],"tags":[]},{"location":"release-guide/2.2/notes/","level":1,"title":"2.2 Release Notes","text":"<p>Overview</p> <ul> <li>Release Date: October 1, 2025</li> <li>Changelog: Link </li> </ul>","path":["Release Guide","Release 2.2","2.2 Release Notes"],"tags":[]},{"location":"release-guide/2.2/notes/#notable-changes","level":2,"title":"Notable Changes","text":"<ul> <li>A new method, <code>Wallet::apply_update_events</code>, returns a list of events that were contained in the update when applied on the wallet. Learn more about this feature here.</li> <li>The signer module has been deprecated and is planned to be removed in a future release.</li> </ul>","path":["Release Guide","Release 2.2","2.2 Release Notes"],"tags":[]},{"location":"release-guide/2.2/wallet-events/","level":1,"title":"Applying Updates to a Wallet Returns A List of Events","text":"<p>Overview</p> <ul> <li>Lead Developer: @notmandatory</li> <li>Ticket: #6</li> <li>Pull Request: #310</li> <li>ADR: Link</li> <li>Feature Type: Non-breaking</li> </ul>","path":["Release Guide","Release 2.2","Applying Updates to a Wallet Returns A List of Events"],"tags":[]},{"location":"release-guide/2.2/wallet-events/#overview","level":2,"title":"Overview","text":"<p>A new method is provided for applying a blockchain data update to the <code>Wallet</code> that returns a list of events the update generates.</p> <pre><code>let events: Vec&lt;WalletEvent&gt; = wallet.apply_update_events(update);\n</code></pre> <p>The WalletEvent is an enum with variants that signal things like a change in the blockchain tip, a new transaction confirmed, a transaction has been RBF'd, etc.</p> <pre><code>enum WalletEvent {\n    ChainTipChanged {\n        old_tip: BlockId,\n        new_tip: BlockId,\n    },\n    TxConfirmed {\n        txid: Txid,\n        tx: Arc&lt;Transaction&gt;,\n        block_time: ConfirmationBlockTime,\n    },\n    /// ...\n}\n</code></pre>","path":["Release Guide","Release 2.2","Applying Updates to a Wallet Returns A List of Events"],"tags":[]},{"location":"release-guide/2.2/wallet-events/#why-do-this","level":2,"title":"Why Do This?","text":"<p>When syncing a <code>Wallet</code> with new blockchain data using Wallet::apply_update, it does not return any value on success, and only a <code>CannotConnectError</code> if it fails. </p> <p>Users have asked for a concise list of events that reflect if or how new blockchain data has changed the blockchain tip and the status of transactions relevant to the wallet's balance. This information is useful for downstream libraries who rely on these events for triggering their own work, as well as for applications who want to notify users of wallet changes after syncing.</p>","path":["Release Guide","Release 2.2","Applying Updates to a Wallet Returns A List of Events"],"tags":[]},{"location":"release-guide/2.2/wallet-events/#applying-an-update-to-wallet-now-returns-vecwalletevent","level":2,"title":"Applying An Update to Wallet Now Returns <code>Vec&lt;WalletEvent&gt;</code>","text":"<p>This new feature adds a <code>WalletEvent</code> enum of user-facing events that are generated when a blockchain data update is applied to a wallet using the <code>Wallet::apply_update_events</code> function. The <code>WalletEvent</code> enum includes an event for changes in blockchain tip and events for changes to the status of transactions that are relevant to the wallet, including:</p> <ol> <li>Newly seen in the mempool</li> <li>Replaced in the mempool </li> <li>Dropped from the mempool</li> <li>Confirmed in a block</li> <li>Confirmed in a new block due to a reorg</li> <li>Unconfirmed due to a reorg</li> </ol> <p>Chain tip change events are generated by comparing the wallet's chain tip before and after applying an update. Wallet transaction events are generated by comparing a snapshot of the wallet's canonical transactions before and after applying the update.</p> <p>As long as updates to the wallet are not persisted until after all events are processed by the caller, then if the app crashes for some reason and the wallet is re-sync'd a new update will re-return the same events.</p> <p>The <code>WalletEvent</code> enum is non-exhaustive.</p> <p></p>","path":["Release Guide","Release 2.2","Applying Updates to a Wallet Returns A List of Events"],"tags":[]},{"location":"release-guide/2.3/notes/","level":1,"title":"2.3 Release Notes","text":"<p>Overview</p> <ul> <li>Release Date: December 5, 2025</li> <li>Changelog: Link </li> </ul>","path":["Release Guide","Release 2.3","2.3 Release Notes"],"tags":[]},{"location":"release-guide/2.3/notes/#notable-changes","level":2,"title":"Notable Changes","text":"<ul> <li>Adds new methods <code>Wallet::apply_block_events</code> and <code>Wallet::apply_block_connected_to_events</code>. Learn more about this feature here.</li> <li>A fix was added to <code>Wallet::build_fee_bump</code> so that it does not throw an error when missing a parent transaction when the input UTXO was added to the original, pre-fee-bump transaction with <code>TxBuilder::add_foreign_utxo</code>.</li> </ul>","path":["Release Guide","Release 2.3","2.3 Release Notes"],"tags":[]},{"location":"release-guide/2.3/wallet-events/","level":1,"title":"Applying Blocks to a Wallet Returns A List of Events","text":"<p>Overview</p> <ul> <li>Lead Developer: @tnull</li> <li>Ticket: #6</li> <li>Pull Request: #336</li> <li>ADR: Link</li> <li>Feature Type: Non-breaking</li> </ul>","path":["Release Guide","Release 2.3","Applying Blocks to a Wallet Returns A List of Events"],"tags":[]},{"location":"release-guide/2.3/wallet-events/#overview","level":2,"title":"Overview","text":"<p>New methods are provided for applying a block to the <code>Wallet</code> that return a list of events the block generates.</p> <pre><code>let events: Vec&lt;WalletEvent&gt; = wallet.apply_block_events(block, height);\n// OR\nlet events: Vec&lt;WalletEvent&gt; = wallet.apply_block_connected_to_events(block, height, connected_to);\n</code></pre>","path":["Release Guide","Release 2.3","Applying Blocks to a Wallet Returns A List of Events"],"tags":[]},{"location":"release-guide/2.3/wallet-events/#why-do-this","level":2,"title":"Why Do This?","text":"<p>When syncing a <code>Wallet</code> with new blockchain data using Wallet::apply_block or Wallet::apply_block_connected_to, they do not return any value on success, and only a <code>CannotConnectError</code> if they fail. </p> <p>Users have asked for a concise list of events that reflect if or how new blockchain data has changed the blockchain tip and the status of transactions relevant to the wallet's balance. This information is useful for downstream libraries who rely on these events for triggering their own work, as well as for applications who want to notify users of wallet changes after syncing.</p>","path":["Release Guide","Release 2.3","Applying Blocks to a Wallet Returns A List of Events"],"tags":[]},{"location":"release-guide/2.3/wallet-events/#applying-a-block-to-wallet-now-returns-vecwalletevent","level":2,"title":"Applying A Block to Wallet Now Returns <code>Vec&lt;WalletEvent&gt;</code>","text":"<p>This new feature returns <code>WalletEvent</code> user-facing events that are generated when a new block is applied to a wallet using the <code>Wallet::apply_block_events</code> or <code>Wallet::apply_block_connected_to_events</code> function. </p> <p></p>","path":["Release Guide","Release 2.3","Applying Blocks to a Wallet Returns A List of Events"],"tags":[]}]}