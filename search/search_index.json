{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Bitcoin Development Kit","text":"<p>The Bitcoin Development Kit (BDK) project was created to provide well engineered and reviewed components for building bitcoin-based applications.</p> <p>The core components of BDK are written in the Rust language and live in the <code>bitcoindevkit/bdk</code> repository. The core BDK components are built upon the excellent <code>rust-bitcoin</code> and <code>rust-miniscript</code> crates.</p> <p>The BDK team also maintains the <code>bitcoindevkit/bdk-ffi</code> repository which provide cross-platform versions of the high level BDK APIs. Platforms currently supported by the BDK team include: Kotlin (Android, Linux, macOS), Swift (iOS, macOS), and Python (Linux, macOS, Windows). There are also various 3rd party supported bindings for other languages, including Flutter, ReactNative, and JavaScript (WASM bindings for Browser/Node/ReactNative).</p>"},{"location":"cookbook/starter-example/","title":"Simple Starter Example","text":""},{"location":"cookbook/starter-example/#overview","title":"Overview","text":"<p>So you want to build a bitcoin wallet using BDK. Great! Here is the rough outline of what you need to do just that. A standard, simple example of a bitcoin wallet in BDK-land would require 3 core pillars:</p> The 3 core pieces of a BDK wallet. <ol> <li>The <code>bdk_wallet</code> library, which will provide two core types: the <code>Wallet</code> and the <code>TxBuilder</code>. This library will handle all the domain logic related to keeping track of which UTXOs you own, what your total balance is, creating and signing transactions, etc.</li> <li>A blockchain client. Your wallet will need to keep track of blockchain data, like new transactions that have been added to the blockchain that impact your wallet, requesting these transactions from a Bitcoin Core node, an Electrum or Esplora server, etc.</li> <li>A persistence mechanism for saving wallet data between sessions (note that this is not actually required). Things like which addresses the wallet has revealed and what is the state of the blockchain on its last sync are things that are kept in persistence and can be loaded on startup.</li> </ol>"},{"location":"cookbook/starter-example/#diving-in","title":"Diving in!","text":"<p>This page provides a starter example showcasing how BDK can be used to create, sync, and manage a wallet using an Esplora client as a blockchain data source. Familiarity with this example will help you work through the more advanced pages in this section.</p> <p>You can find working code examples of this example in three programming languages: Rust, Swift, and Kotlin. (Note: some additional language bindings are available for BDK, see 3rd Party Bindings).</p> <p>Tip</p> <p>To complete this example from top to bottom, you'll need to create new descriptors and replace the ones provided. Once you do so, you'll run the example twice; on first run the wallet will not have any balance and will exit with an address to send funds to. Once that's done, you can run the example again and the wallet will be able to perform the later steps, namely creating and broadcasting a new transaction.</p>"},{"location":"cookbook/starter-example/#create-a-new-project","title":"Create a new project","text":"RustSwiftKotlin <pre><code>cargo init starter-example\ncd starter-example\n</code></pre> <pre><code>swift package init --type executable\n</code></pre> <pre><code>gradle init\n</code></pre>"},{"location":"cookbook/starter-example/#add-required-dependencies","title":"Add required dependencies","text":"RustSwiftKotlin Cargo.toml<pre><code>[package]\nname = \"starter-example\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nbdk_wallet = { version = \"2.2.0\", features = [\"rusqlite\"] }\nbdk_esplora = { version = \"0.22.1\", features = [\"blocking\"] }\n</code></pre> <p>Package.swift<pre><code>\n</code></pre> Or, if you're building an iOS app:</p> <ol> <li>From the Xcode File menu, select Add Package Dependencies...</li> <li>Enter <code>https://github.com/bitcoindevkit/bdk-swift</code> into the package repository URL search field and bdk-swift should come up</li> <li>For the Dependency Rule select <code>Exact Version</code>, enter the version number (same as Package.swift) and click Add Package</li> </ol> build.gradle.kts<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    // for JVM\n    implementation(\"org.bitcoindevkit:bdk-jvm:1.1.0\")\n    // for Android\n    implementation(\"org.bitcoindevkit:bdk-android:1.1.0\")\n}\n</code></pre>"},{"location":"cookbook/starter-example/#use-descriptors","title":"Use descriptors","text":"<p>To create a wallet using BDK, we need some descriptors for our wallet. This example uses public descriptors (meaning they cannot be used to sign transactions) on Signet. Step 7 and below will fail unless you replace those public descriptors with private ones of your own and fund them using Signet coins through a faucet. Refer to the Creating Descriptors page for information on how to generate your own private descriptors.</p> <p>Warning</p> <p>Note that if you replace the descriptors after running the example using the provided ones, you must delete or rename the database file or will get an error on wallet load.</p> RustSwiftKotlin <pre><code>let descriptor: &amp;str = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\";\nlet change_descriptor: &amp;str = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\";\n</code></pre> <pre><code>let descriptor = try Descriptor(descriptor: \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\", network: Network.signet)\nlet changeDescriptor = try Descriptor(descriptor: \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\", network: Network.signet)\n</code></pre> <pre><code>val descriptor = Descriptor(\"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\", Network.SIGNET)\nval changeDescriptor = Descriptor(\"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\", Network.SIGNET)\n</code></pre> <p>These are taproot descriptors (<code>tr()</code>) using public keys on Signet (<code>tpub</code>) as described in BIP86. The first descriptor is an HD wallet with a path for generating addresses to give out externally for payments. The second one is used by the wallet to generate addresses to pay ourselves change when sending payments (remember that UTXOs must be spent in full, so you often need to make change).</p>"},{"location":"cookbook/starter-example/#create-or-load-a-wallet","title":"Create or load a wallet","text":"<p>Next let's load up our wallet.</p> RustSwiftKotlin examples/rust/starter-example/src/main.rs<pre><code>// Initiate the connection to the database\nlet mut conn = Connection::open(DB_PATH).expect(\"Can't open database\");\n\n// Create the wallet\nlet wallet_opt = Wallet::load()\n    .descriptor(KeychainKind::External, Some(descriptor))\n    .descriptor(KeychainKind::Internal, Some(change_descriptor))\n    // .extract_keys() // uncomment this line when using private descriptors\n    .check_network(Network::Signet)\n    .load_wallet(&amp;mut conn)\n    .unwrap();\n\nlet mut wallet = if let Some(loaded_wallet) = wallet_opt {\n    loaded_wallet\n} else {\n    Wallet::create(descriptor, change_descriptor)\n        .network(Network::Signet)\n        .create_wallet(&amp;mut conn)\n        .unwrap()\n};\n</code></pre> <pre><code>let wallet: Wallet\nlet connection: Connection\n\nif FileManager.default.fileExists(atPath: dbFilePath.path) {\n    print(\"Loading up existing wallet\")\n    connection = try Connection(path: dbFilePath.path)\n    wallet = try Wallet.load(\n        descriptor: descriptor,\n        changeDescriptor: changeDescriptor,\n        connection: connection\n    )\n} else {\n    print(\"Creating new wallet\")\n    connection = try Connection(path: dbFilePath.path)\n    wallet = try Wallet(\n        descriptor: descriptor,\n        changeDescriptor: changeDescriptor,\n        network: Network.signet,\n        connection: connection\n    )\n}\n</code></pre> examples/kotlin/starter-example/src/.../App.kt<pre><code>val persistenceExists = File(PERSISTENCE_FILE_PATH).exists()\nval connection = Connection(PERSISTENCE_FILE_PATH)\n\nval wallet = if (persistenceExists) {\n    println(\"Loading up existing wallet\")\n    Wallet.load(\n        descriptor = descriptor,\n        changeDescriptor = changeDescriptor,\n        connection = connection\n    )\n} else {\n    println(\"Creating new wallet\")\n    Wallet(\n        descriptor = descriptor,\n        changeDescriptor = changeDescriptor,\n        network = Network.SIGNET,\n        connection = connection\n    )\n}\n</code></pre>"},{"location":"cookbook/starter-example/#sync-the-wallet","title":"Sync the wallet","text":"<p>Now let's build an Esplora client and use it to request transaction history for the wallet.</p> RustSwiftKotlin examples/rust/starter-example/src/main.rs<pre><code>// Sync the wallet\nlet client: esplora_client::BlockingClient =\n    Builder::new(\"https://blockstream.info/signet/api/\").build_blocking();\n\nprintln!(\"Syncing wallet...\");\nlet full_scan_request: FullScanRequestBuilder&lt;KeychainKind&gt; = wallet.start_full_scan();\nlet update: FullScanResponse&lt;KeychainKind&gt; = client\n    .full_scan(full_scan_request, STOP_GAP, PARALLEL_REQUESTS)\n    .unwrap();\n\n// Apply the update from the full scan to the wallet\nwallet.apply_update(update).unwrap();\n\nlet balance = wallet.balance();\nprintln!(\"Wallet balance: {} sat\", balance.total().to_sat());\n</code></pre> <pre><code>let esploraClient = EsploraClient(url: \"https://blockstream.info/signet/api/\")\nlet fullScanRequest = try wallet.startFullScan().build()\nlet update = try esploraClient.fullScan(\n    request: fullScanRequest,\n    stopGap: UInt64(10),\n    parallelRequests: UInt64(1)\n)\ntry wallet.applyUpdate(update: update)\nlet balance = wallet.balance()\nprint(\"Wallet balance: \\(balance.total.toSat()) sat\")\n</code></pre> examples/kotlin/starter-example/src/.../App.kt<pre><code>val esploraClient: EsploraClient = EsploraClient(SIGNET_ESPLORA_URL)\nval fullScanRequest: FullScanRequest = wallet.startFullScan().build()\nval update = esploraClient.fullScan(\n    request = fullScanRequest,\n    stopGap = 10uL,\n    parallelRequests = 1uL\n)\nwallet.applyUpdate(update)\nval balance = wallet.balance().total.toSat()\nprintln(\"Balance: $balance\")\n</code></pre> <p>In cases where you are using new descriptors that do not have a balance yet, the example will request a new address from the wallet and print it out so you can fund the wallet. Remember that this example uses Signet coins!</p> RustSwiftKotlin examples/rust/starter-example/src/main.rs<pre><code>if balance.total().to_sat() &lt; 5000 {\n    println!(\"Your wallet does not have sufficient balance for the following steps!\");\n    // Reveal a new address from your external keychain\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\n        \"Send Signet coins to {} (address generated at index {})\",\n        address.address, address.index\n    );\n    wallet.persist(&amp;mut conn).expect(\"Cannot persist\");\n    exit(0)\n}\n</code></pre> <pre><code>if (balance.total.toSat() &lt; UInt64(5000)) {\n    print(\"Your wallet does not have sufficient balance for the following steps!\");\n    let address = wallet.revealNextAddress(keychain: KeychainKind.external)\n    print(\"Send Signet coins to address \\(address.address) (address generated at index \\(address.index))\")\n    try wallet.persist(connection: connection)\n    exit(0)\n}\n</code></pre> examples/kotlin/starter-example/src/.../App.kt<pre><code>if (balance &lt; 5000uL) {\n    println(\"Your wallet does not have sufficient balance for the following steps!\");\n    val address = wallet.revealNextAddress(KeychainKind.EXTERNAL)\n    println(\"Send Signet coins to address ${address.address} (address generated at index ${address.index})\")\n    wallet.persist(connection)\n    exitProcess(0)\n}\n</code></pre>"},{"location":"cookbook/starter-example/#send-a-transaction","title":"Send a transaction","text":"<p>For this step you'll need a wallet built with private keys, funded with some Signet satoshis. You can find a faucet here to get some coins.</p> <p>Let's prepare to send a transaction. The two core choices here are where to send the funds and how much to send. We will send funds back to the faucet return address; it's good practice to send test sats back to the faucet when you're done using them.</p> RustSwiftKotlin examples/rust/starter-example/src/main.rs<pre><code>// Use a faucet return address\nlet faucet_address =\n    Address::from_str(\"tb1p4tp4l6glyr2gs94neqcpr5gha7344nfyznfkc8szkreflscsdkgqsdent4\")\n        .unwrap()\n        .require_network(Network::Signet)\n        .unwrap();\n\nlet send_amount: Amount = Amount::from_sat(4000);\n</code></pre> <pre><code>let faucetAddress: Address = try Address(address: \"tb1p4tp4l6glyr2gs94neqcpr5gha7344nfyznfkc8szkreflscsdkgqsdent4\", network: Network.signet)\nlet amount: Amount = Amount.fromSat(fromSat: UInt64(4000))\n</code></pre> examples/kotlin/starter-example/src/.../App.kt<pre><code>val esploraClient: EsploraClient = EsploraClient(SIGNET_ESPLORA_URL)\nval fullScanRequest: FullScanRequest = wallet.startFullScan().build()\nval update = esploraClient.fullScan(\n    request = fullScanRequest,\n    stopGap = 10uL,\n    parallelRequests = 1uL\n)\nwallet.applyUpdate(update)\nval balance = wallet.balance().total.toSat()\nprintln(\"Balance: $balance\")\n</code></pre> <p>Here we are sending 5000 sats back to the faucet (make sure the wallet has at least this much balance, or change this value).</p> <p>Finally we are ready to build, sign, and broadcast the transaction:</p> RustSwiftKotlin examples/rust/starter-example/src/main.rs<pre><code>let mut builder = wallet.build_tx();\nbuilder\n    .fee_rate(FeeRate::from_sat_per_vb(4).unwrap())\n    .add_recipient(faucet_address.script_pubkey(), send_amount);\n\nlet mut psbt: Psbt = builder.finish().unwrap();\n\nlet finalized = wallet.sign(&amp;mut psbt, SignOptions::default()).unwrap();\nassert!(finalized);\n\nlet tx = psbt.extract_tx().unwrap();\nclient.broadcast(&amp;tx).unwrap();\nprintln!(\"Transaction broadcast! Txid: {}\", tx.compute_txid());\n</code></pre> <pre><code>let psbt: Psbt = try TxBuilder()\n    .addRecipient(script: faucetAddress.scriptPubkey(), amount: amount)\n    .feeRate(feeRate: try FeeRate.fromSatPerVb(satPerVb: UInt64(7)))\n    .finish(wallet: wallet)\n\ntry wallet.sign(psbt: psbt)\nlet tx: Transaction = try psbt.extractTx()\nesploraClient.broadcast(tx)\nprint(\"Transaction broadcast successfully! Txid: \\(tx.computeTxid())\")\n</code></pre> examples/kotlin/starter-example/src/.../App.kt<pre><code>val psbt: Psbt = TxBuilder()\n    .addRecipient(script = faucetAddress.scriptPubkey(), amount = amount)\n    .feeRate(FeeRate.fromSatPerVb(7uL))\n    .finish(wallet)\n\nwallet.sign(psbt)\nval tx: Transaction = psbt.extractTx()\nesploraClient.broadcast(tx)\nprintln(\"Transaction broadcast successfully! Txid: ${tx.computeTxid()}\")\n</code></pre> <p>We can view our transaction on the mempool.space Signet explorer.</p>"},{"location":"cookbook/wasm/","title":"WASM Example","text":"<p>WASM bindings can be used to access rust code from virtually any JavaScript environment: browsers, Node.js, ReactNative, etc.</p> <p>Info</p> <p>This page details how to build a custom WASM package that uses BDK rust crate under the hood. If you want an out of the box solution for JS(WASM) bindings for BDK which don't require writing any rust code, see the WASM section on the 3rd Party Bindings page for a pre-packaged npm module.</p> <p>Because rust can compile to WASM, it is possible to use BDK in the browser. However, there are a few limitations to keep in mind which will be highlighted in this example. That being said, there are perfectly viable work-arounds for these limitations that should suffice for most use cases.</p> <p>Warning</p> <p>There are several limitations to using BDK in WASM. Basically any functionality that requires OS access is not directly available in WASM and must therefore be handled in JavaScript. Some key limitations include:</p> <ul> <li>No access to the file system</li> <li>No access to the system time</li> <li>Network access is limited to http(s)</li> </ul>"},{"location":"cookbook/wasm/#wasm-considerations-overview","title":"WASM Considerations Overview","text":""},{"location":"cookbook/wasm/#no-access-to-the-file-system","title":"No access to the file system","text":"<p>With no direct access to the file system, persistence cannot be handled by BDK directly. Instead, an in memory wallet must be used in the WASM environment, and the data must be exported through a binding to the JavaScript environment to be persisted.</p>"},{"location":"cookbook/wasm/#no-access-to-the-system-time","title":"No access to the system time","text":"<p>Any function that requires system time, such as any sort of timestamp, must access system time through a wasm binding to the JavaScript environment. This means some BDK functions that are commonly used in rust won't work in WASM and instead an alternate rust function that takes a timestamp as an argument must be used (I.E. instead of <code>.apply_update()</code> we must use <code>.apply_update_at()</code>).</p>"},{"location":"cookbook/wasm/#network-access-is-limited-to-https","title":"Network access is limited to http(s)","text":"<p>This effectively means that the blockchain client must be an Esplora instance. Both RPC and Electrum clients require sockets and will not work for BDK in a WASM environment out of the box.</p>"},{"location":"cookbook/wasm/#troubleshooting","title":"Troubleshooting","text":"<p>WASM errors can be quite cryptic, so it's important to understand the limitations of the WASM environment. One common error you might see while running a BDK function through a WASM binding in the browser is <code>unreachable</code>. This error likely will not point you to the actual BDK function that is causing the error. Instead you need to be able to assess whether you are calling a function that uses a rust feature that is unsupported in the WASM environment. For example, if you do a scan and then try to use <code>.apply_update()</code> you will get an <code>unreachable</code> error. This is because <code>.apply_update()</code> requires system time, which is not available in the WASM environment. Instead you need to use <code>.apply_update_at()</code> which takes an explicit timestamp as an argument (see below).</p>"},{"location":"cookbook/wasm/#wasm-app-example","title":"WASM App Example","text":"<p>In this example we will cover basic BDK functionality in a WASM environment. We will show code snippets for both the rust and JavaScript necessary to create a custom WASM package, and we will highlight the key differences from the plain rust examples (due to WASM limitations).</p> <p>Info</p> <p>The WASM example code is split into two project folders: a rust project that uses wasm-pack to compile rust code to WASM files, and a JavaScript project that pulls the WASM project as a dependency. The JS project represents the web app and the rust project is used to generate an npm module.</p>"},{"location":"cookbook/wasm/#initializing-a-wallet","title":"Initializing a Wallet","text":"<p>From JS running in our browser, first we need our descriptors:</p> <pre><code>const externalDescriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\";\nconst internalDescriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\";\n</code></pre> <p>Then we can initialize the wallet, we'll use some conditional logic here to either 1) create a new wallet and perform a full scan, or 2) load a wallet from stored data and sync it to get recent updates.</p> <pre><code>let walletDataString = Store.load();\nconsole.log(\"Wallet data:\", walletDataString);\n\nlet wallet;\nif (!walletDataString) {\n    console.log(\"Creating new wallet\");\n    wallet = new WalletWrapper(\n        \"signet\",\n        externalDescriptor,\n        internalDescriptor,\n        \"https://mutinynet.com/api\"\n    );\n\n    console.log(\"Performing Full Scan...\");\n    await wallet.scan(2);\n\n    const stagedDataString = wallet.take_staged();\n    console.log(\"Staged:\", stagedDataString);\n\n    Store.save(stagedDataString);\n    console.log(\"Wallet data saved to local storage\");\n    walletDataString = stagedDataString;\n} else {\n    console.log(\"Loading wallet\");\n    wallet = WalletWrapper.load(\n        walletDataString,\n        \"https://mutinynet.com/api\",\n        externalDescriptor,\n        internalDescriptor\n    );\n\n    console.log(\"Syncing...\");\n    await wallet.sync(2);\n\n    const stagedDataString = wallet.take_staged();\n    console.log(\"Staged:\", stagedDataString);\n\n    Store.save(stagedDataString);\n    console.log(\"Wallet data saved to local storage\");\n}\n</code></pre>"},{"location":"cookbook/wasm/#network-consideration","title":"Network Consideration","text":"<p>Notice we are including blockchain client details in wallet initialization (Signet, and the esplora url). This is because we are forced to use esplora, so we may as well initialize the client at the same time as the wallet.</p> <p>Here is the relevant rust code:</p> <pre><code>#[wasm_bindgen(constructor)]\npub fn new(\n    network: String,\n    external_descriptor: String,\n    internal_descriptor: String,\n    esplora_url: String,\n) -&gt; Result&lt;WalletWrapper, String&gt; {\n    let network = match network.as_str() {\n        \"mainnet\" =&gt; Network::Bitcoin,\n        \"testnet\" =&gt; Network::Testnet,\n        \"testnet4\" =&gt; Network::Testnet4,\n        \"signet\" =&gt; Network::Signet,\n        \"regtest\" =&gt; Network::Regtest,\n        _ =&gt; return Err(\"Invalid network\".into()),\n    };\n\n    let wallet_opt = Wallet::load()\n        .descriptor(KeychainKind::External, Some(external_descriptor.clone()))\n        .descriptor(KeychainKind::Internal, Some(internal_descriptor.clone()))\n        .extract_keys()\n        .check_network(network)\n        .load_wallet_no_persist(ChangeSet::default())\n        .map_err(|e| format!(\"{:?}\", e))?;\n\n    let wallet = match wallet_opt {\n        Some(wallet) =&gt; wallet,\n        None =&gt; Wallet::create(external_descriptor, internal_descriptor)\n            .network(network)\n            .create_wallet_no_persist()\n            .map_err(|e| format!(\"{:?}\", e))?,\n    };\n\n    let client = esplora_client::Builder::new(&amp;esplora_url)\n        .max_retries(6)\n        .build_async_with_sleeper()\n        .map_err(|e| format!(\"{:?}\", e))?;\n\n    Ok(WalletWrapper { wallet, client })\n}\n\npub fn load(\n    changeset_str: &amp;str,\n    url: &amp;str,\n    external_descriptor: &amp;str,\n    internal_descriptor: &amp;str,\n) -&gt; JsResult&lt;WalletWrapper&gt; {\n    let changeset_value: Value = serde_json::from_str(changeset_str)?;\n    let changeset: ChangeSet = serde_json::from_value(changeset_value)?;\n\n    let wallet_opt = Wallet::load()\n        .descriptor(\n            KeychainKind::External,\n            Some(external_descriptor.to_string()),\n        )\n        .descriptor(\n            KeychainKind::Internal,\n            Some(internal_descriptor.to_string()),\n        )\n        .extract_keys()\n        .load_wallet_no_persist(changeset)?;\n\n    let wallet = match wallet_opt {\n        Some(wallet) =&gt; wallet,\n        None =&gt; return Err(JsError::new(\"Failed to load wallet, check the changeset\")),\n    };\n\n    let client = esplora_client::Builder::new(&amp;url).build_async_with_sleeper()?;\n\n    Ok(WalletWrapper { wallet, client })\n}\n\npub async fn scan(&amp;mut self, stop_gap: usize) -&gt; Result&lt;(), String&gt; {\n    let wallet = &amp;mut self.wallet;\n    let client = &amp;self.client;\n\n    let request = wallet.start_full_scan();\n\n    let update = client\n        .full_scan(request, stop_gap, PARALLEL_REQUESTS)\n        .await\n        .map_err(|e| format!(\"{:?}\", e))?;\n\n    let now = (Date::now() / 1000.0) as u64;\n    wallet\n        .apply_update_at(update, now)\n        .map_err(|e| format!(\"{:?}\", e))?;\n\n    Ok(())\n}\n\npub async fn sync(&amp;mut self, parallel_requests: usize) -&gt; JsResult&lt;()&gt; {\n    let request = self.wallet.start_sync_with_revealed_spks();\n    let update = self.client.sync(request, parallel_requests).await?;\n\n    let now = (Date::now() / 1000.0) as u64;\n    self.wallet.apply_update_at(update, now)?;\n\n    Ok(())\n}\n</code></pre> <p>The first time you load the page in your browser, you should see info in the console confirming that a new wallet was created and a full scan was performed. If you then reload the page you should see that the wallet was loaded from the previously saved data and a sync was performed instead of a full scan.</p>"},{"location":"cookbook/wasm/#system-time-consideration","title":"System Time Consideration","text":"<p>Notice we are using a JS binding to access system time with <code>js_sys::Date::now()</code>, then passing that timestamp to the <code>apply_update_at()</code> function, rather than attempting to use the <code>.apply_update()</code> function which would throw an error.</p>"},{"location":"cookbook/wasm/#persistence-consideration","title":"Persistence Consideration","text":"<p>Also notice we are using an in-memory wallet with <code>.create_wallet_no_persist()</code>. If you try to use persistence through file or database you will get an error because those features require OS access. Instead we have to create a binding to pass the wallet data to the JavaScript environment where we can handle persistence. We have a method to grab the new updates to the wallet data, and a method to merge new updates with existing data. With this simple approach to persistence we must always merge existing data with the updates unless there is no existing data (i.e. after new wallet creation). The rust side methods to extract the wallet data are:</p> <pre><code>pub fn take_staged(&amp;mut self) -&gt; JsResult&lt;String&gt; {\n    match self.wallet.take_staged() {\n        Some(changeset) =&gt; {\n            let value = serde_json::to_value(&amp;changeset)?;\n            Ok(serde_json::to_string(&amp;value)?)\n        }\n        None =&gt; Ok(\"null\".to_string()),\n    }\n}\n\npub fn take_merged(&amp;mut self, previous: String) -&gt; JsResult&lt;String&gt; {\n    match self.wallet.take_staged() {\n        Some(curr_changeset) =&gt; {\n            let previous_value: Value = serde_json::from_str(&amp;previous)?;\n            let mut previous_changeset: ChangeSet = serde_json::from_value(previous_value)?;\n            previous_changeset.merge(curr_changeset);\n            let final_value = serde_json::to_value(&amp;previous_changeset)?;\n            Ok(serde_json::to_string(&amp;final_value)?)\n        }\n        None =&gt; Ok(\"null\".to_string()),\n    }\n}\n</code></pre> <p>Notice we're converting the wallet data to a JSON string so that it plays nicely with WASM; and on the JS side we'll save our data string with a minimal custom browser store:</p> <pre><code>// simple string storage example\nconst Store = {\n    save: data =&gt; {\n        if (!data) {\n            console.log(\"No data to save\");\n            return;\n        }\n        localStorage.setItem(\"walletData\", data);  // data is already a JSON string\n    },\n    load: () =&gt; {\n        return localStorage.getItem(\"walletData\");  // return the JSON string directly\n    }\n}\n</code></pre> <p>This is just to show an example of how the wallet data can be persisted. We're using local storage here, but in practice a wallet app would generally use cloud storage of some sort since browser local storage tends to be temporary.</p>"},{"location":"cookbook/wasm/#balance-and-addresses","title":"Balance and Addresses","text":"<p>We can now get the balance of our wallet and generate a new address. Here is the JS code:</p> <pre><code>// Test balance\nconsole.log(\"Balance:\", wallet.balance());\n\n// Test address generation\nconsole.log(\"New address:\", wallet.reveal_next_address());\n\n// handle changeset merge on rust side\nconst mergedDataString = wallet.take_merged(walletDataString);\n\nconsole.log(\"Merged:\", mergedDataString);\n\nStore.save(mergedDataString);\nconsole.log(\"new address saved\");\n</code></pre> <p>Here is the rust code that gets called:</p> <pre><code>pub fn balance(&amp;self) -&gt; u64 {\n    let balance = self.wallet.balance();\n    balance.total().to_sat()\n}\n\npub fn reveal_next_address(&amp;mut self) -&gt; String {\n    let address = self.wallet.reveal_next_address(KeychainKind::External);\n\n    address.to_string()\n}\n</code></pre> <p>Notice we call <code>take_merged()</code> and <code>Store.save()</code> after generating a new address so our wallet keeps track of generated addresses (so we don't re-use them). If you reload the browser you can see the generated address value updated along with the index.</p>"},{"location":"cookbook/keys-descriptors/descriptors/","title":"Creating Keys and Descriptors","text":"<p>BDK is a descriptor-first library. This page explores how to build them and how they interact with other standards like BIP-39 recovery phrases.</p> <p>Danger</p> <p>The keys and descriptors used in The Book of BDK are for illustration purposes only; UNDER NO CIRCUMSTANCES should any of the keys or descriptors containing private data be used for real money. Entropy generation should be carried out in a secure environment using cryptographically secure random number generators (CSPRNG).</p>"},{"location":"cookbook/keys-descriptors/descriptors/#using-descriptor-templates","title":"Using descriptor templates","text":"<p>BDK offers utility constructs called descriptor templates, which allow you to build descriptors for the four most common script types (BIP 44/49/84/86) with minimal effort.</p> <p>The following will build and print the full string representation of taproot (BIP-86) internal and external descriptors. We print both the public key descriptors (for HD wallet address generation only) and private key descriptors (for full wallet functionality including transaction signing).</p> <pre><code>let mut seed: [u8; 32] = [0u8; 32];\nrand::thread_rng().fill_bytes(&amp;mut seed);\n\nlet network: Network = Network::Signet;\nlet xprv: Xpriv = Xpriv::new_master(network, &amp;seed).unwrap();\nprintln!(\"Generated Master Private Key:\\n{}\\nWarning: be very careful with private keys when using MainNet! We are logging these values for convenience only because this is an example on SigNet.\\n\", xprv);\n\nlet (descriptor, key_map, _) = Bip86(xprv, KeychainKind::External)\n    .build(Network::Signet)\n    .expect(\"Failed to build external descriptor\");\n\nlet (change_descriptor, change_key_map, _) = Bip86(xprv, KeychainKind::Internal)\n    .build(Network::Signet)\n    .expect(\"Failed to build internal descriptor\");\n\nlet descriptor_string_priv = descriptor.to_string_with_secret(&amp;key_map);\nlet change_descriptor_string_priv = change_descriptor.to_string_with_secret(&amp;change_key_map);\n</code></pre>"},{"location":"cookbook/keys-descriptors/recovery-phrases/","title":"Generate Descriptors from Recovery Phrases","text":"<p>BDK wallets require the use of descriptors, but recovery phrases (also called seed phrases) are a common and popular backup solution. Creating descriptors from a recovery phrase is a common workflow and BDK makes this easy with its descriptor templates, which are offered for common descriptors (BIP 44/49/84/86).</p> <p>Feature Flags</p> <p>The current example requires the feature <code>keys-bip39</code> for <code>bdk_wallet</code>. Add it to your <code>Cargo.toml</code> file with:</p> <pre><code>bdk_wallet = { version = \"2.2.0\", features = [\"keys-bip39\"] }\n</code></pre>"},{"location":"cookbook/keys-descriptors/recovery-phrases/#example","title":"Example","text":"<pre><code>let recovery_phrase: &amp;str = \"awesome awesome awesome awesome awesome awesome awesome awesome awesome awesome awesome awesome\";\nlet mnemonic = Mnemonic::parse(recovery_phrase).expect(\"Invalid seed! Be sure to replace the value of RECOVERY_PHRASE with your own 12 word seed phrase.\");\nlet seed = mnemonic.to_seed(\"\");\nlet xprv: Xpriv = Xpriv::new_master(Network::Signet, &amp;seed).expect(\"Failed to create master key\");\n\nprintln!(\"# Master Private Key\\n{xprv}\\nWarning: be very careful with seeds and private keys when using MainNet! We are logging these values for convenience and demonstration purposes only.\\n\");\n\nlet (descriptor, key_map, _) = Bip86(xprv, KeychainKind::External)\n    .build(Network::Signet)\n    .expect(\"Failed to build external descriptor\");\n\nlet (change_descriptor, change_key_map, _) = Bip86(xprv, KeychainKind::Internal)\n    .build(Network::Signet)\n    .expect(\"Failed to build internal descriptor\");\n</code></pre>"},{"location":"cookbook/persistence/memory/","title":"In-Memory Wallet","text":"<p>The simplest wallet is one that does not have any persistence. All information about the wallet is held in memory, and will be destroyed upon termination of the process.</p> <p>In-memory implies that the addresses the wallet has revealed, the syncing that has been performed including data on the transaction graph will not persist when the wallet is destroyed, and related operations will need to be performed again.</p> <p>In general, this means performing a <code>full_scan()</code> when starting the wallet, because it has no knowledge of which addresses were given out and which scripts still have balances.</p> <p>See our page on the difference between the full scan and sync operations for more on this topic.</p>"},{"location":"cookbook/persistence/memory/#example","title":"Example","text":"<p>The in-memory wallet does not require any additional dependencies beyond the <code>bdk_wallet</code> dependency:</p> Cargo.toml<pre><code>[dependencies]\nbdk_wallet = { version = \"2.2.0\" }\n</code></pre> <p>To create an in-memory wallet, simply call <code>create_wallet_no_persist()</code> on the <code>Wallet</code> builder:</p> main.rs<pre><code>let mut wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n    .network(Network::Signet)\n    .create_wallet_no_persist()\n    .expect(\"valid wallet\");\n</code></pre> <p></p>"},{"location":"cookbook/persistence/sqlite/","title":"SQLite Database","text":"<p>The SQLite persistence is a great default for many use cases, and is a good place to start if you're not sure which persistence to choose from.</p> <p>By default when using the <code>bdk_wallet</code> library, all information about the wallet is held in memory, and will be destroyed upon termination of the process unless saved to persistence. </p> <p>When information important to the wallet is added to it, the wallet will add it to its staged area. Whenever you want to save this information to persistence, call the <code>Wallet.persist(&amp;mut db)</code>.</p> <p>The operations that affect the wallet and produce a changeset are things like:</p> <ul> <li>Revealing new addresses</li> <li>Sync operations that pick up new UTXOs</li> </ul> <p>Once those things are persisted, upon loading of the database changeset the wallet would be able to rehydrate its TxGraph, which includes UTXOs, transaction history, and latest blocks known to the wallet. This means that a wallet that's been loaded from such a persistence will not require a Full Scan but rather simply a Sync.</p> <p>See our page on the difference between the full scan and sync operations for more on this topic.</p>"},{"location":"cookbook/persistence/sqlite/#example","title":"Example","text":"<p>The sqlite wallet does not require any additional dependencies above the <code>bdk_wallet</code> dependency:</p> Cargo.toml<pre><code>[dependencies]\nbdk_wallet = { version = \"2.1.0\", features = [\"rusqlite\"] }\n</code></pre> <p>To load an existing sqlite-based persisted wallet use <code>Wallet::load()</code>. You may then optionally verify the loaded descriptors match what you expect. If the provided descriptors contain private keys you can also extract these keys into the wallets keystore. Private keys are never stored in the wallet database. You may also verify the wallet network during loading.</p> <pre><code>let network = Network::Signet;\nlet file_path = \"test_wallet.sqlite3\";\nlet mut conn = rusqlite::Connection::open(file_path)?;\n\nlet wallet_opt = Wallet::load()\n    .descriptor(KeychainKind::External, Some(EXTERNAL_DESCRIPTOR))\n    .descriptor(KeychainKind::Internal, Some(INTERNAL_DESCRIPTOR))\n    .extract_keys() // only needed if using private key descriptors\n    .check_network(network)\n    .load_wallet(&amp;mut conn)?;\n</code></pre> <p>If during wallet loading no wallet database file is found you can create a sqlite-based persisted wallet with <code>Wallet::create()</code> with a valid db connection and other wallet builder parameters:</p> <pre><code>let mut wallet = match wallet_opt {\n    Some(wallet) =&gt; {\n        println!(\"Loaded existing wallet database.\");\n        wallet\n    }\n    None =&gt; {\n        println!(\"Creating new wallet database.\");\n        Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n            .network(network)\n            .create_wallet(&amp;mut conn)?\n    }\n};\n</code></pre> <p>After performing an operation that returns data that should be persisted, use the <code>persist()</code> method on the wallet:</p> <pre><code>// Reveal a new address from your external keychain\nlet address = wallet.reveal_next_address(KeychainKind::External);\nwallet.persist(&amp;mut conn)?;\n// Only share new address with user after successfully persisting wallet\nprintln!(\n    \"Generated address {} at index {}\",\n    address.address, address.index\n);\n</code></pre> <p></p>"},{"location":"cookbook/syncing/electrum/","title":"Sync a Wallet with Electrum","text":"<p>Syncing with Electrum uses what we refer to as SPK-based syncing (see our Full Scan vs Sync page for more information on this).</p> <p>The workflow for a full scan or sync consists of a 3-step process:</p> <ol> <li>Ask the wallet for the data structure required.</li> <li>Pass it to your blockchain client and request a full scan or sync.</li> <li>The client returns an update, which you then apply to the wallet.</li> </ol> <p>This workflow ensures that the wallet structure is not blocked while the syncing operation is performed.</p>"},{"location":"cookbook/syncing/electrum/#add-required-bdk-dependencies-to-your-cargotoml-file","title":"Add required bdk dependencies to your <code>Cargo.toml</code> file","text":"Cargo.toml<pre><code>[dependencies]\nbdk_wallet = { version = \"2.1.0\" }\nbdk_electrum = { version = \"0.23.1\" }\n</code></pre>"},{"location":"cookbook/syncing/electrum/#create-and-sync-the-wallet","title":"Create and sync the wallet","text":"main.rs<pre><code>use bdk_electrum::electrum_client::Client;\nuse bdk_electrum::{electrum_client, BdkElectrumClient};\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::AddressInfo;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::Wallet;\n\nconst STOP_GAP: usize = 50;\nconst BATCH_SIZE: usize = 5;\nconst EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/0/*)#g9xn7wf9\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/1/*)#e3rjrmea\";\n\nfn main() {\n    let mut wallet: Wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n        .network(Network::Signet)\n        .create_wallet_no_persist()\n        .unwrap();\n\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\n        \"Generated address {} at index {}\",\n        address.address, address.index\n    );\n\n    // Create the Electrum client\n    let client: BdkElectrumClient&lt;Client&gt; =\n        BdkElectrumClient::new(electrum_client::Client::new(\"ssl://mempool.space:60602\").unwrap());\n\n    // Perform the initial full scan on the wallet\n    let full_scan_request = wallet.start_full_scan();\n    let update = client\n        .full_scan(full_scan_request, STOP_GAP, BATCH_SIZE, true)\n        .unwrap();\n\n    wallet.apply_update(update).unwrap();\n    let balance = wallet.balance();\n    println!(\"Wallet balance: {} sat\", balance.total().to_sat());\n}\n</code></pre>"},{"location":"cookbook/syncing/esplora/","title":"Sync a Wallet with Esplora","text":"<p>Syncing with Esplora uses what we refer to as SPK-based syncing (see our Full Scan vs Sync page for more information on this).</p> <p>The workflow for a full scan or sync consists of a 3-step process:</p> <ol> <li>Ask the wallet for the data structure required.</li> <li>Pass it to your blockchain client and request a full scan or sync.</li> <li>The client returns an update, which you then apply to the wallet.</li> </ol> <p>This workflow ensures that the wallet structure is not blocked while the syncing operation is performed.</p>"},{"location":"cookbook/syncing/esplora/#add-required-bdk-dependencies-to-your-cargotoml-file","title":"Add required bdk dependencies to your Cargo.toml file","text":"Cargo.toml<pre><code>[dependencies]\nbdk_wallet = { version = \"2.1.0\" }\nbdk_esplora = { version = \"0.22.1\", features = [\"blocking\"] }\nanyhow = \"1\"\n</code></pre>"},{"location":"cookbook/syncing/esplora/#create-and-sync-the-wallet","title":"Create and sync the wallet","text":"main.rs<pre><code>use anyhow::Error;\nuse bdk_esplora::esplora_client::Builder;\nuse bdk_esplora::{esplora_client, EsploraExt};\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::chain::spk_client::{\n    FullScanRequestBuilder, FullScanResponse, SyncRequestBuilder, SyncResponse,\n};\nuse bdk_wallet::AddressInfo;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::Wallet;\n\nconst STOP_GAP: usize = 50;\nconst PARALLEL_REQUESTS: usize = 1;\nconst EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/0/*)#g9xn7wf9\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/1/*)#e3rjrmea\";\n\nfn main() -&gt; Result&lt;(), Error&gt; {\n    let mut wallet: Wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n        .network(Network::Signet)\n        .create_wallet_no_persist()?;\n\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\n        \"Generated address {} at index {}\",\n        address.address, address.index\n    );\n\n    //--8&lt;-- [start:client]\n    // Create the Esplora client\n    let client: esplora_client::BlockingClient =\n        Builder::new(\"https://blockstream.info/signet/api/\").build_blocking();\n    //--8&lt;-- [end:client]\n\n    //--8&lt;-- [start:scan]\n    // Full scan the wallet\n    let full_scan_request: FullScanRequestBuilder&lt;KeychainKind&gt; = wallet.start_full_scan();\n    let full_scan_response: FullScanResponse&lt;KeychainKind&gt; =\n        client.full_scan(full_scan_request, STOP_GAP, PARALLEL_REQUESTS)?;\n\n    // Apply the full scan response to the wallet\n    wallet.apply_update(full_scan_response)?;\n    //--8&lt;-- [end:scan]\n\n    //--8&lt;-- [start:sync]\n    // Sync the wallet\n    let sync_request: SyncRequestBuilder&lt;(KeychainKind, u32)&gt; =\n        wallet.start_sync_with_revealed_spks();\n    let sync_response: SyncResponse = client.sync(sync_request, PARALLEL_REQUESTS)?;\n\n    // Apply the sync response to the wallet\n    wallet.apply_update(sync_response)?;\n    //--8&lt;-- [end:sync]\n\n    let balance = wallet.balance();\n    println!(\"Wallet balance: {} sat\", balance.total().to_sat());\n\n    Ok(())\n}\n</code></pre>"},{"location":"cookbook/syncing/full-scan-vs-sync/","title":"Full Scan vs Sync","text":"<p>Two of the four blockchain client libraries maintained by BDK (Electrum and Esplora) use what we refer to as SPK-based syncing (as opposed to block-by-block syncing). This SPK-based syncing relies on two concepts we call Full Scan and Sync. This page explains the difference between the two, the tradeoffs made when choosing each, and recommendations on when to use them.</p>"},{"location":"cookbook/syncing/full-scan-vs-sync/#full-scan","title":"Full Scan","text":"<p>A full scan is an operation that aims to build a complete picture of a wallet's UTXOs from scratch, with no prior data or knowledge about the wallet. It involves querying the blockchain data client for ScriptPubKeys that the wallet owns, typically at a number of indices on the wallet's keychains. </p> <p>Because the wallet doesn't know which scripts/addresses have been given out and potentially have funds associated with them, it needs to query the blockchain client for a group of addresses, see if any of those have balances, and keep asking for more until a number of addresses in a row for each keychain are unused (the exact number is configurable and is what's typically known as a stop gap). The operation also returns a new chain tip the wallet uses to update its <code>LocalChain</code>.</p> <p>A full scan is needed in cases where the wallet is unknown and is not loaded from persistence, or in cases where other software wallets might have revealed/used addresses on the keychains since the last time the wallet was used (like how some users might have wallets they use on both mobile apps and desktop applications, and the mobile wallet has no way of knowing if the desktop wallet was used since the last time it was synced up).</p>"},{"location":"cookbook/syncing/full-scan-vs-sync/#sync","title":"Sync","text":"<p>A sync is a related operation which can be thought of as \"catching up\" on the latest things that have happened on the chain since the last full scan or sync. A sync only makes sense if the list of addresses given out is known, and will query the blockchain data client for those scripts only. It also returns a new chain tip the wallet uses to update its <code>LocalChain</code>.</p> <p>A sync is a smaller and more optimal operation than a full scan, and should often be used in cases after an initial full scan has been performed.</p>"},{"location":"cookbook/syncing/full-scan-vs-sync/#practical-examples","title":"Practical Examples","text":"<p>Here are 4 different examples with wallets of different sizes and stop gap choices. The numbers in the Full Scan and Sync columns are the resulting number of scripts requested to the Electrum or Esplora instances.</p> Example Addr. Revealed Stop Gap Full Scan Sync A 7 20 27 7 B 7 1000 1007 7 C 500 20 520 500 D 500 1000 1500 500"},{"location":"cookbook/syncing/full-scan-vs-sync/#additional-considerations-server-load","title":"Additional Considerations \u2014 Server Load","text":"<p>Note that the choice of full scan vs sync as well as the stop gap on the wallet influences the load on the server infrastructure that services those requests. Whether these servers are maintained by you or you are using publicly available servers, understanding those choices is important.</p> <p>In particular, the difference between a full scan and a sync depends on your choice of stop gap and the current size of the wallet like so:</p> <ol> <li>If the stop gap is small, the difference between your sync and full scan will be smaller than if the stop gap is very big. Wallets A and B above have revealed 7 addresses each, yet wallet B's full scan is more than 100x its sync while wallet A's is only 4x. Using a sync on wallet B will make a big difference on your server load (particularly if you sync often).</li> <li>The difference between the full scan and sync diminishes the bigger the wallet becomes. On a very small wallet (wallets A and B above), the stop gap makes a big part of the number of SPKs synced, whereas for bigger wallets , the stop gap makes up a much smaller percentage of the total number of SPKs synced. For example on wallet C (big wallet but small stop gap) the difference between the full scan and the sync is minimal.</li> </ol>"},{"location":"cookbook/syncing/full-scan-vs-sync/#additional-considerations-sync-but-not-always","title":"Additional Considerations \u2014 Sync, But Not Always!","text":"<p>We can think of a sync as a more narrow but optimized approach to syncing. It works really well for some situations, but is less applicable as a \"one-worklflow-to-rule-them-all\". In particular, wallets where the user might also be using their descriptors on other software can create problems with the sync workflow, since the wallet is not aware that new addresses have been revealed, and will not include them in its sync request.</p> <p>Here are situations for which sync works and performs best:</p> <ul> <li>Cases where you know the user only uses their descriptors with the current wallet (for example if the user has specified this as a toggle in settings), and a full scan has already been performed once.</li> <li>Situations where you call your syncing workflow on a loop, and you can safely assume that you're the only user of the descriptors at any given time. For example if you loop on 15s intervals you could have your loop full scan on first iteration and sync on further iterations, with a full scan every X number of minutes/iterations.</li> </ul> <p>Production applications need either a mix of both (and if so the option to trigger a full scan on user request, not just on first startup), or, if they want to only use one, use the full scan (to cover all cases and situations where users use their backups on different wallets/software).</p>"},{"location":"cookbook/syncing/full-scan-vs-sync/#additional-considerations-general-heuristics","title":"Additional Considerations \u2014 General Heuristics","text":"<p>The following heuristics work well for most standard wallets:</p> <ol> <li>If you are recovering a wallet which currently holds or has ever held a balance or are creating a wallet from scratch, your first syncing operation should be a full scan. This allows the wallet to discover which scripts have been used and create an accurate overall balance. If your sofware is certain that the users is only using their descriptors with this wallet, all other syncing operations can be sync.</li> <li>If you are loading a wallet from persistence for which a full scan has already been performed and related data has been persisted, your syncing operations can be sync. If you believe some addresses have been revealed in the meantime, do a full scan on startup.</li> <li>If you are operating on a wallet which is shared with other entities which might reveal addresses, your local wallet and its <code>TxGraph</code> will not know about these revealed scripts. In this case, and if you suspect addresses might have been revealed, you should perform a full scan.</li> </ol>"},{"location":"cookbook/syncing/full-scan-vs-sync/#additional-considerations-really-big-wallets","title":"Additional Considerations \u2014 Really Big Wallets","text":"<p>On really big wallets, a custom, application-defined choice of which spks to sync at any given time/trigger is probably more appropriate.</p> <p>For example, if a wallet has 2500 addresss revealed and your application tries to stay on a 10s loop... it is not a good idea (and doesn't really make sense anyway) to try and sync it all on every iteration.</p> <p>Some pooling of the spks in different buckets would probably work best, and this would be defined at the application layer. Variables to include in the choice of which SPKs to sync would probably include last known transaction for the SPK and last time it was synced.</p> <p></p>"},{"location":"cookbook/syncing/kyoto/","title":"Sync a wallet with Kyoto","text":"<p>BIP157 and BIP158 define a protocol for light clients to sync with the Bitcoin network without downloading the entire set of blocks in the chain of most work. These proposals define compact block filters, which allow a client to download a small commitment for the scripts contained in each block. These commitments, or filters, may be checked for inclusion of scripts owned by a user. In the event of a match, the light client may download and verify a block indeed contains a relevant transaction. Syncing via compact block filters offers privacy advantages over other chain sources, as the nodes serving the blocks to the client are only aware that the client is interested in an entire block, which may contain thousands of transactions.</p> <p>One such implementation of this protocol is Kyoto, which is a node and client for compact block filter based syncing. The <code>bdk_kyoto</code> crate supports an integration between Kyoto and <code>bdk_wallet</code>, so developers using <code>bdk_wallet</code> have a simple option to provide privacy-preserving and memory-conservative wallet syncing for their users.</p> <p>The following example uses the <code>bdk_kyoto</code> crate to recover and update a <code>bdk_wallet</code> using compact block filters.</p>"},{"location":"cookbook/syncing/kyoto/#add-required-bdk-dependencies-to-your-cargotoml-file","title":"Add required bdk dependencies to your <code>Cargo.toml</code> file","text":"Cargo.toml<pre><code>[package]\nname = \"kyoto\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nbdk_kyoto = { version = \"0.13.1\" }\nbdk_wallet = { version = \"2.1.0\" }\ntokio = { version = \"1\", features = [\"full\"], default-features = false }\ntracing = { version = \"0.1\" }\ntracing-subscriber = { version = \"0.3\" }\n</code></pre>"},{"location":"cookbook/syncing/kyoto/#create-and-sync-the-wallet","title":"Create and sync the wallet","text":"main.rs<pre><code>use bdk_kyoto::builder::{NodeBuilder, NodeBuilderExt};\nuse bdk_kyoto::{Info, LightClient, Receiver, ScanType, UnboundedReceiver, Warning};\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::{KeychainKind, Wallet};\nuse tokio::select;\n\nconst RECEIVE: &amp;str = \"tr([7d94197e/86'/1'/0']tpubDCyQVJj8KzjiQsFjmb3KwECVXPvMwvAxxZGCP9XmWSopmjW3bCV3wD7TgxrUhiGSueDS1MU5X1Vb1YjYcp8jitXc5fXfdC1z68hDDEyKRNr/0/*)\";\nconst CHANGE: &amp;str = \"tr([7d94197e/86'/1'/0']tpubDCyQVJj8KzjiQsFjmb3KwECVXPvMwvAxxZGCP9XmWSopmjW3bCV3wD7TgxrUhiGSueDS1MU5X1Vb1YjYcp8jitXc5fXfdC1z68hDDEyKRNr/1/*)\";\nconst RECOVERY_HEIGHT: u32 = 190_000;\nconst RECOVERY_LOOKAHEAD: u32 = 50;\nconst NUM_CONNECTIONS: u8 = 1;\nconst NETWORK: Network = Network::Signet;\n\n/// Implement a custom logger that prints log messages to the console.\nasync fn trace_logs(\n    mut log_rx: Receiver&lt;String&gt;,\n    mut info_rx: Receiver&lt;Info&gt;,\n    mut warn_rx: UnboundedReceiver&lt;Warning&gt;,\n) {\n    loop {\n        select! {\n            log = log_rx.recv() =&gt; {\n                if let Some(log) = log {\n                    tracing::info!(\"{log}\")\n                }\n            }\n            warn = warn_rx.recv() =&gt; {\n                if let Some(warn) = warn {\n                    tracing::warn!(\"{warn}\")\n                }\n            }\n            info = info_rx.recv() =&gt; {\n                if let Some(info) = info {\n                    tracing::info!(\"{info}\")\n                }\n            }\n        }\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    // Initialize tracing\n    let subscriber = tracing_subscriber::FmtSubscriber::new();\n    tracing::subscriber::set_global_default(subscriber).unwrap();\n\n    // Apply the recovery lookahead to the wallet\n    let mut wallet = Wallet::create(RECEIVE, CHANGE)\n        .network(NETWORK)\n        .lookahead(RECOVERY_LOOKAHEAD)\n        .create_wallet_no_persist()\n        .unwrap();\n\n    let scan_type = ScanType::Recovery {\n        from_height: RECOVERY_HEIGHT,\n    };\n\n    // Build a node that will find and connect to peers, gather relevant blocks, and broadcast transactions.\n    // In addition, receive a client that allows for communication with a running node to receive wallet\n    // updates, relay transactions to the node, and get updates on the node's actions.\n    let LightClient {\n        requester,\n        log_subscriber,\n        info_subscriber,\n        warning_subscriber,\n        mut update_subscriber,\n        node,\n    } = NodeBuilder::new(NETWORK)\n        .required_peers(NUM_CONNECTIONS)\n        .build_with_wallet(&amp;wallet, scan_type)\n        .unwrap();\n\n    // Run the node on a separate task. The node will run continuously until instructed by the client\n    // to stop. The node will attempt to stay in sync with its peers by listening for messages as long\n    // as the application is running.\n    tokio::task::spawn(async move { node.run().await });\n\n    // Trace the logs with a custom function.\n    tokio::task::spawn(async move {\n        trace_logs(log_subscriber, info_subscriber, warning_subscriber).await\n    });\n\n    // Sync and apply updates to the wallet. We can do this a continual loop while the application is running.\n    // Often this would occur on a separate thread than the underlying application user interface.\n    let update = update_subscriber.update().await.unwrap();\n    wallet.apply_update(update).unwrap();\n    tracing::info!(\"Tx count: {}\", wallet.transactions().count());\n    tracing::info!(\"Balance: {}\", wallet.balance().total().to_sat());\n    let last_revealed_external = wallet.derivation_index(KeychainKind::External).unwrap_or(0);\n    tracing::info!(\"Last revealed External: {}\", last_revealed_external);\n    let last_revealed_internal = wallet.derivation_index(KeychainKind::Internal).unwrap_or(0);\n    tracing::info!(\"Last revealed Internal: {}\", last_revealed_internal);\n    tracing::info!(\"Local chain tip: {}\", wallet.local_chain().tip().height());\n    let next = wallet.peek_address(KeychainKind::External, last_revealed_external + 1);\n    tracing::info!(\"Next receiving address: {next}\");\n    requester.add_script(next.address).unwrap();\n    requester.shutdown().unwrap();\n}\n</code></pre>"},{"location":"cookbook/syncing/kyoto/#a-note-on-unconfirmed-transactions-recoveries-sync-and-full-scan","title":"A note on unconfirmed transactions, recoveries, sync and full-scan","text":"<p>The entire set of scripts is checked against each block filter as new blocks are gossiped to the Kyoto node. Because the scripts are not checked iteratively, there is not a semantic difference between \"sync\" and \"full scan\". Rather, Kyoto is made aware of the <code>lookahead</code> number of scripts ahead of the last revealed index for each keychain in the wallet when the node is built. To recover a wallet, the <code>lookahead</code> should be set to a number greater than or equal to the number of scripts revealed by the wallet. Developers can and should add scripts to check for filter inclusions by calling <code>add_script</code> when transactions are built or addresses are revealed.</p> <p>Unconfirmed transactions pose a problem for light clients, as connections are untrusted. As such, users will be unaware of transactions they have received until they are confirmed in a block. While this tradeoff may be cumbersome, the benefits may outweigh the costs for privacy-conscious users.</p>"},{"location":"cookbook/syncing/rpc/","title":"Sync a Wallet with Bitcoin Core RPC","text":""},{"location":"cookbook/syncing/rpc/#1-start-a-regtest-bitcoin-daemon","title":"1. Start a regtest bitcoin daemon","text":"<p>For this example you'll need to run a bitcoin core daemon locally in regtest mode. Here are some of the commands you'll need: <pre><code># In a shell dedicated to the bitcoin daemon \nbitcoind --chain=regtest\n\n# In a new shell dedicated to the bitcoin-cli\nbitcoin-cli --chain=regtest getblockchaininfo\n\nbitcoin-cli --chain=regtest createwallet mywallet\nbitcoin-cli --chain=regtest loadwallet mywallet\nbitcoin-cli --chain=regtest getnewaddress\n\n# Mine 101 blocks\nbitcoin-cli --chain=regtest generatetoaddress 101 &lt;address&gt;\n\n# Send to address\nbitcoin-cli --chain=regtest sendtoaddress &lt;address&gt; &lt;amount&gt;\n</code></pre></p>"},{"location":"cookbook/syncing/rpc/#2-create-a-new-rust-project","title":"2. Create a new Rust project","text":"<pre><code>cargo init rpcexample\ncd rpcexample\n</code></pre>"},{"location":"cookbook/syncing/rpc/#3-add-required-bdk-dependencies-to-your-cargotoml-file","title":"3. Add required bdk dependencies to your <code>Cargo.toml</code> file","text":"Cargo.toml<pre><code>[package]\nname = \"rpc\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nbdk_wallet = { version = \"2.1.0\" }\nbdk_bitcoind_rpc = {  version = \"0.21.0\" }\n</code></pre>"},{"location":"cookbook/syncing/rpc/#4-create-your-descriptors","title":"4. Create your descriptors","text":"<p>Refer to the Working with Descriptors page for information on how to generate descriptors. This page will assume you are working on Regtest with the following BIP86 descriptors: <pre><code>const EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/0/*)#g9xn7wf9\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/1/*)#e3rjrmea\";\n</code></pre></p>"},{"location":"cookbook/syncing/rpc/#5-create-and-sync-wallet","title":"5. Create and sync wallet","text":"main.rs<pre><code>use std::sync::Arc;\n\nuse bdk_bitcoind_rpc::bitcoincore_rpc::{Auth, Client, RpcApi};\nuse bdk_bitcoind_rpc::{Emitter, NO_EXPECTED_MEMPOOL_TXS};\nuse bdk_wallet::bitcoin::{Network, Transaction};\nuse bdk_wallet::chain::local_chain::CheckPoint;\nuse bdk_wallet::{AddressInfo, Balance, KeychainKind, Wallet};\n\nconst COOKIE_FILE_PATH: &amp;str = \"&lt;path_to_your_regtest_bitcoin_core_data_dir&gt;/.cookie\";\nconst EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/0/*)#g9xn7wf9\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/1/*)#e3rjrmea\";\n\nfn main() {\n    let mut wallet: Wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n        .network(Network::Regtest)\n        .create_wallet_no_persist()\n        .unwrap();\n\n    let balance: Balance = wallet.balance();\n    println!(\"Wallet balance before syncing: {}\", balance.total());\n\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\n        \"Generated address {} at index {}\",\n        address.address, address.index\n    );\n\n    let rpc_client: Client = Client::new(\n        \"http://127.0.0.1:18443\",\n        // Auth::UserPass(\"__cookie__\".to_string(), \"cookievalue\".to_string())\n        Auth::CookieFile(COOKIE_FILE_PATH.into()),\n    )\n    .unwrap();\n\n    let blockchain_info = rpc_client.get_blockchain_info().unwrap();\n    println!(\n        \"\\nConnected to Bitcoin Core RPC.\\nChain: {}\\nLatest block: {} at height {}\\n\",\n        blockchain_info.chain, blockchain_info.best_block_hash, blockchain_info.blocks,\n    );\n\n    let wallet_tip: CheckPoint = wallet.latest_checkpoint();\n    println!(\n        \"Current wallet tip is: {} at height {}\",\n        &amp;wallet_tip.hash(),\n        &amp;wallet_tip.height()\n    );\n\n    let mut emitter = Emitter::new(\n        &amp;rpc_client,\n        wallet_tip.clone(),\n        wallet_tip.height(),\n        NO_EXPECTED_MEMPOOL_TXS,\n    );\n\n    println!(\"Syncing blocks...\");\n    while let Some(block) = emitter.next_block().unwrap() {\n        print!(\"{} \", block.block_height());\n        wallet\n            .apply_block_connected_to(&amp;block.block, block.block_height(), block.connected_to())\n            .unwrap();\n    }\n    println!();\n\n    println!(\"Syncing mempool...\");\n    let mempool_emissions: Vec&lt;(Arc&lt;Transaction&gt;, u64)&gt; = emitter.mempool().unwrap().update;\n    wallet.apply_unconfirmed_txs(mempool_emissions);\n\n    let balance: Balance = wallet.balance();\n    println!(\"Wallet balance after syncing: {}\", balance.total());\n}\n</code></pre> <p>Once you have synced the wallet once, mine a few new blocks using the bitcoin-cli and send coins to the address provided by the wallet and printed in the console. Upon running the example code again, your wallet will sync up the latest blocks and update its balance.</p>"},{"location":"cookbook/transactions/transaction-builder/","title":"Transaction Builder","text":"<p>The Transaction Builder provides a convenient way to construct bitcoin transactions by offering a builder-type API that helps developers manage the typical requirements for building transactions: recipients, fees, signatures, and a whole lot more.</p>"},{"location":"cookbook/transactions/transaction-builder/#features","title":"Features","text":"<ul> <li>Flexible Input and Output Selection: You can add or subtract inputs and outputs as needed.</li> <li>Fees: The builder calculates and adds fees automatically based on a specified fee rate or absolute target.</li> <li>Finalization: The builder helps finalize the transaction, ensuring signatures and other conditions are met.</li> </ul>"},{"location":"cookbook/transactions/transaction-builder/#usage","title":"Usage","text":"<p>To start building a new transaction, instantiate the <code>TxBuilder</code> type provided by BDK by calling the <code>Wallet::build_tx()</code> method. On this builder you chain various methods to add inputs, outputs, and configure other settings. Finally, call <code>TxBuilder::finish()</code> to get a PSBT ready for signing.</p> <pre><code>let psbt = wallet.build_tx()\n    .add_recipient(address.script_pubkey(), amount)\n    .finish()?;\n</code></pre>"},{"location":"cookbook/transactions/transaction-builder/#customizing-outputs","title":"Customizing Outputs","text":"<p>You can specify multiple recipients for the transaction, distributing funds across various addresses. The output is added as a script with an amount:</p> <pre><code>wallet.build_tx()\n    .add_recipient(to_address1.script_pubkey(), amount1)\n    .add_recipient(to_address2.script_pubkey(), amount2)\n</code></pre>"},{"location":"cookbook/transactions/transaction-builder/#choosing-inputs","title":"Choosing Inputs","text":"<p>You can manually select specific UTXOs, as well as request to not spend specific UTXOs:</p> <pre><code>wallet.build_tx()\n    .add_utxo(utxo1)?\n    .add_unspendable(utxo2)\n    .add_recipient(address.script_pubkey(), amount)\n</code></pre> <p>Combining the above with <code>TxBuilder::manually_selected_only</code> will ensure that the wallet only spends UTXOs specified by the <code>TxBuilder::add_utxo</code> method.</p> <p>Alternatively, let the wallet choose the inputs:</p> <pre><code>wallet.build_tx()\n    .add_recipient(address.script_pubkey(), amount)\n</code></pre>"},{"location":"cookbook/transactions/transaction-builder/#fee-management","title":"Fee Management","text":"<p>The builder allows you to define a fee rate or an absolute fee:</p> <pre><code>wallet.build_tx()\n    .fee_rate(FeeRate::from_sat_per_vb(4))\n    .fee_absolute(Amount::from_sat(600))\n</code></pre> <p>Note that if you set the fee using both the fee_absolute and the fee_rate method, the wallet will use method was called last, as the fee rate and the absolute fee amount are mutually exclusive.</p>"},{"location":"cookbook/transactions/transaction-builder/#spend-all-funds","title":"Spend all funds","text":"<p>The transaction builder has a convenience method that will spend all UTXOs available to it (while respecting the unspendable UTXOs if any). Simple use of this method will simply increase the size of your change output, but you can combine it with the <code>TxBuilder::drain_to</code> method to ensure all funds are sent to a specific address:</p> <pre><code>\n</code></pre>"},{"location":"cookbook/transactions/transaction-builder/#set-the-nsequence-value","title":"Set the nSequence value","text":"<p>The <code>TxBuilder::set_exact_sequence</code> method allows users to set their nSequence value directly. This is also the way you would disable signaling for RBF, as the TxBuilder will by default enable it.</p> <pre><code>wallet.build_tx()\n    .add_recipient(address.script_pubkey(), amount)\n    .set_exact_sequence(sequence)\n</code></pre>"},{"location":"cookbook/transactions/transaction-builder/#finalizing-the-psbt","title":"Finalizing the PSBT","text":"<p>Once you\u2019ve added inputs, outputs, and calculated the fees, you can build the psbt using the <code>TxBuilder::finish</code> method.</p> <pre><code>let psbt = wallet.build_tx()\n    .finish()?;\n</code></pre> <p>The result is a PSBT ready to be signed and later on broadcast to the network.</p>"},{"location":"cookbook/transactions/transaction-builder/#signing-the-psbt-and-extracting-the-transaction","title":"Signing the PSBT and extracting the transaction","text":"<p>Sign the PSBT using the <code>Wallet::sign</code> method and extract the finalized transaction from it using the Psbt::extract_tx` method for a ready-to-be-broadcast transaction.</p> <pre><code>wallet.sign(&amp;mut psbt, SignOptions::default())?;\nlet tx = psbt.extract_tx()?;\n</code></pre>"},{"location":"design/cbf/","title":"Preface","text":"<p>In my conversations with wallet developers, I've seen some common themes come up when it comes to compact block filters. Generally developers can quantify some of the properties of syncing wallets with compact block filters, but oftentimes the implementation details are fuzzy. With this blog, I am going to dive into the details, and share what to expect if you are considering block filters. Not all platforms, wallets and users would benefit from block filters, but my hope is to convince you, the developer, that both simple and private wallet syncing is possible for your app!</p>"},{"location":"design/cbf/#the-protocol","title":"The Protocol","text":"<p>It's best to start with what it means to be a \"compact block filter client\". A compact block filter is a concise representation of what bitcoin scripts are in a block. These filters can be queried for a match against scripts that the user owns. Oftentimes these filters are only a few hundred bytes. A client is simply a program that downloads these filters for a particular range of blocks, queries them, and downloads the block in the case of a match.</p> <p>You may have a couple questions now: 1. Who is serving the filters? 2. How does the client know what filters to request?</p> <p>The answer to 1. is relatively simple. Any computer running a full-archival bitcoin node, like Bitcoin Core, can serve filters by selecting the configurations. That's it! The answer to 2. is a bit more interesting. The client must download the block headers from peers they connect to and decide what the chain of most proof of work is. Once the client has decided on a chain, the filters may be downloaded and queried.</p> <p>Notice</p> <p>Some steps are omitted for simplicity, however the primary actions for the client are: select a chain, download filters, download blocks</p> <p>This implies a few things. First, the client must communicate using the bitcoin peer-to-peer protocol, which is facilitated directly using TCP connections. This can be an advantage to your apps, as no HTTPS dependencies are required, reducing the binary size and potential for CVE vulnerabilities. Next, the client must store some information about chain, albeit not that much data. Third, the client must maintain a list and find peers to connect to, which we will dive into later.</p>"},{"location":"design/cbf/#why-do-all-of-this","title":"Why do all of this?","text":"<p>A primary advantage of using block filters is user privacy. Requesting the block filters does not reveal any sensitive information, and bitcoin blocks are often full of many transactions. The client may also connect to multiple nodes and randomly select who to request blocks from. For users that have low resource devices, but would like strong privacy guarantees, block filters are the perfect option.</p> <p>The reliability of block filters is also dependent on the properties of the bitcoin network. If a reasonable amount of nodes are discover-able and serving filters, then the user experience is seamless and reliable. In contrast, using server-based protocols may incur rate-limiting and downtime. For users broadcasting transactions, this also implies they should never have to broadcast transactions to the same node twice, another great privacy win.</p> <p>On the experimental side, the block filter client is a \"pseudo-node\" itself. New types of wallets may run the client 24/7, and constantly sync the user's wallet with the chain. From the perspective of the user, their sync speed would be as fast as it takes to log-in to their dedicated server! My hope is block filters will invigorate self-hosting businesses and products for users to run their own infrastructure.</p>"},{"location":"design/cbf/#the-numbers","title":"The Numbers","text":"<p>We've reviewed some of the properties, let's look at the metrics. We will begin with some on-device data, and transition into network-wide statistics.</p>"},{"location":"design/cbf/#storage","title":"Storage","text":"<p>The impact on storage is minimal. At the time of writing, for the client to follow the chain of most work, roughly 0.072 gigabytes is required to store at a maximum. Most users will be using SegWit or Taproot, so this footprint should be more like 0.030 gigabytes. The book of addresses a client must maintain is configurable, but a reasonable list is only around 0.50 - 1.0 megabytes!</p>"},{"location":"design/cbf/#memory","title":"Memory","text":"<p>The use of memory is also low. For syncing a month or two of data, the runtime overhead is around 30 to 40 megabytes, as measured on an iPhone. For recovering wallets, this may reach 70 to 80 megabytes, but this still doesn't come close to an application like YouTube.</p>"},{"location":"design/cbf/#bandwidth","title":"Bandwidth","text":"<p>Bandwidth will fluctuate depending on how many transactions a user expects to send and receive. For a few months of data with a handful of transactions, the network usage should sit around 100 megabytes. However this may change for wallet recoveries. Users can expect to download up to a gigabyte or more for old wallets, so mobile users should be plugged into power and on WiFi for this step. After the initial recovery, users can sync while on the go! Usual syncs should be possible on cellular data in most regions.</p>"},{"location":"design/cbf/#energy-and-cpu-impact","title":"Energy and CPU Impact","text":"<p>There are many hashing operations performed when syncing compact block filters, so the CPU usage tends to be higher than most consumer applications. While this is not a problem for short a duration, users that have not synced their wallet in 6 months or more should likely connect their phone to power. CPU usage may be cleverly spread out as well. If the underlying operating system allows it, scheduling a background sync with the OS when the user is likely to be connected to power will make the user experiences seamless, as their phone has stayed up-to-date with the chain.</p>"},{"location":"design/cbf/#time","title":"Time","text":"<p>Sync times are highly variable, but on WiFi and with a fast per, a year of data can be synced in only a minute or two. Months of data may take 10-30 seconds, and a week should only take a moment. When network conditions are spotty, the numbers are harder to quantify. This is yet another reason to consider scheduling background tasks, as a daily sync should only take a second!</p>"},{"location":"design/cbf/#distribution-of-peers","title":"Distribution of Peers","text":"<p>Developer Nick Johnson ran a census of what services bitcoin nodes are offering. Many nodes were polled - over 300,000 - however only around 11,000 were reachable. Of these, around 1,000 maintain a compact block filters index.</p> <p>On the one hand, having 1,000 potential peers is low considering how many bitcoin nodes exist. Yet that is also great from the client point of view, as the client essentially has 1,000 potential servers. The only problem is the client must poll these peers to find useful ones.</p> <p>A mitigation to polling a bunch of peers is using DNS seeders. These seeders are constantly crawling the bitcoin network and finding good peers, but relying solely on DNS implies a trust in the seeder. This is tricky for wallet developers and users, as they may want a fast syncing experience, but do not want to fully trust the seeder. A great option is to pick some peers from DNS for a sync, and others from the local address book.</p>"},{"location":"design/cbf/#challenges","title":"Challenges","text":"<p>Now we turn to the design space to improve the user experience of light clients. I hope by now you are considering a block filter integration for your users, so here are the last couple caveats to consider.</p>"},{"location":"design/cbf/#unconfirmed-transactions","title":"Unconfirmed Transactions","text":"<p>Many users come to expect an instant feedback when a transaction enters the server's memory pool in which they receive money. This is both a philosophical and technical problem, as current light clients cannot maintain a large memory pool, may not be online at the time of transaction gossip, and cannot validate transactions. Furthermore, even validated transactions may be changed via RBF, and the user may not receive the bitcoin they expect. If your users are advanced in their bitcoin knowledge, they should have at least a vague idea of why they will need to wait for a block.</p> <p>For users that are moving their bitcoin off the exchange for the first time, this wait-time may be confusing or scary. My first suggestion is still to wait for a block confirmation, but to inform the user they should check back in 10 minutes if they expect to receive a payment. Even if the exchange shows the transaction as sent, it should still remain \"pending\", so informative user interfaces are a potential solution to this problem.</p> <p>If that is still not enough, one could connect over the peer-to-peer network and monitor transaction gossip. I advice against this approach on mobile, as there is a non-zero, even high, probability the gossip messages are missed by the time the user opens their app. However, if your app is a self-hosted \"always on\" program, monitoring peer to peer gossip is far more acceptable, as gossip is being monitored even if the user is not logged in.</p>"},{"location":"design/cbf/#fee-estimation","title":"Fee Estimation","text":"<p>Due to the construction of a bitcoin block, the amounts for each input cannot be known with simply the block data itself. One would need the transaction outputs corresponding to the outpoints contained in the block. This data is sometimes referred to as \"undo data\". Unfortunately, this means the light client cannot estimate fee rates for individual transactions in recent blocks.</p> <p>Servers are available to estimate fees, but this re-introduces HTTPs dependencies in the stack. If your use cases involves a small binary and strict dependency graph, there is still a solution to give fee rate approximation. The average fee rate paid in a block may be computed by taking <code>(Coinbase output - Block subidy) / Block Weight</code>. Averages are more effected by outliers, so exceptionally low or high fee rates on individual transactions may skew this number. Yet, it may be good enough for your users. </p> <p>This is an open area of research, and may be further improved with light weight machine learning models. However, if HTTPs is used in your app already, a server is recommended to fetch fees. As a final note, there are a mounting number of use cases for sending the \"undo data\" over the peer-to-peer network. If this feature is implemented, many aspects of the light client experience may be improved, including fee rate estimation.</p>"},{"location":"getting-started/3rd-party-bindings/","title":"3rd Party Bindings","text":"<p>Some organizations are maintaining their own wrappers and language bindings around the BDK libraries. While these are not maintained by the Foundation, they have users in production and are worth looking into!</p>"},{"location":"getting-started/3rd-party-bindings/#wasm","title":"WASM","text":"<p>bdk-wasm</p> <p>Note: The bdk-wasm lib can be used in just about any modern JavaScript environment, including Browser, Node, ReactNative, etc.</p>"},{"location":"getting-started/3rd-party-bindings/#flutter","title":"Flutter","text":"<p>bdk-flutter</p>"},{"location":"getting-started/3rd-party-bindings/#reactnative","title":"ReactNative","text":"<p>bdk-rn</p> <p>Note: the <code>bdk-wasm</code> lib also works for ReactNative.</p>"},{"location":"getting-started/api-documentation/","title":"API Documentation","text":"<p>Our API documentation is available here:</p> <ul> <li>bdk_wallet</li> <li>bdk_chain</li> <li>bdk_file_store</li> <li>bdk_electrum</li> <li>bdk_esplora</li> <li>bdk_bitcoind_rpc</li> <li>bdk_hwi</li> <li>esplora-client</li> <li>electrum-client</li> </ul>"},{"location":"getting-started/bdk-cli/","title":"BDK CLI","text":""},{"location":"getting-started/bdk-cli/#purpose","title":"Purpose","text":"<p>The <code>bdk-cli</code> binary crate is designed as an experimental playground for users to dive into the <code>BDK</code> libraries with ease. </p> <p>Its documentation is available here, and you can explore the source code here.</p>"},{"location":"getting-started/bdk-cli/#features","title":"Features","text":"<p><code>bdk-cli</code> can be compiled with different features to suit your experimental needs.</p>"},{"location":"getting-started/bdk-cli/#database-options","title":"Database Options","text":"<ul> <li><code>sqlite</code>: Sets the wallet database to a sqlite3 db. <code>sqlite</code> is a default feature.</li> </ul>"},{"location":"getting-started/bdk-cli/#blockchain-options","title":"Blockchain Options","text":"<ul> <li><code>rpc</code>: Connects the wallet to bitcoin core via RPC.</li> <li><code>electrum</code>: Connects the wallet to an electrum server.</li> <li><code>esplora</code>: Connects the wallet to an esplora server.</li> <li><code>cbf</code>: Connects the wallet to kyoto - a node and client for compact block filter based syncing.</li> </ul>"},{"location":"getting-started/bdk-cli/#extra-utility-tools","title":"Extra Utility Tools","text":"<ul> <li><code>repl</code>: use bdk-cli as a REPL shell (useful for quick manual testing of wallet operations). <code>repl</code> is also a default feature.</li> <li><code>compiler</code>: opens up bdk-cli policy compiler commands.</li> <li><code>verify</code>: uses bitcoinconsensus to verify transactions at every sync call of the wallet.</li> </ul> <p>These features are non-exhaustive as more features will be added.</p>"},{"location":"getting-started/bdk-cli/#installation","title":"Installation","text":"<p>You have the option to build <code>bdk-cli</code> from its source code or install directly from <code>crates.io</code>.</p> <p>To build from the source:</p> <pre><code>    cd &lt;bdk-cli git repo directory&gt;\n\n    cargo install --path . --features electrum\n\n    bdk-cli help # to verify it worked\n</code></pre> <p>To install from <code>crates.io</code>, run this command:</p> <pre><code>cargo install bdk-cli --features electrum  # add any additional features as needed\n</code></pre> <p>Note that if no blockchain client feature is enabled, online wallet commands will be disabled.</p>"},{"location":"getting-started/bdk-cli/#usage","title":"Usage","text":"<p>To get usage information for the bdk-cli binary use the below command which returns a list of available wallet options and commands:</p> <pre><code>cargo run\n</code></pre> <p>Follow the instruction in descriptors to generate descriptors, selecting your preferred network and descriptor type.</p> <p>Assuming you exported your external and internal descriptors as <code>EXT_DESC</code> and <code>INT_DESC</code>, we can generate a new address by running the following command:</p> <pre><code>cargo run -- --network [selected network] wallet -e $EXT_DESC -i $INT_DESC -d sqlite new_address\n</code></pre> <p>To sync the above wallet to a Bitcoin Core node (assuming a regtest node at 127.0.0.1:18443, username and password of bitcoin:bitcoin), run the following command:</p> <pre><code>cargo run --features rpc wallet -e $EXT_DESC -i $INT_DESC -d sqlite -c rpc -u 127.0.0.1:18443 -a bitcoin:bitcoin sync\n</code></pre> <p>To generate a new extended master key, suitable for use in a descriptor:</p> <p>cargo run -- key generate</p>"},{"location":"getting-started/getting-started/","title":"Getting Started","text":"<p>Notice</p> <p>This book is up-to-date with version <code>1.0.0</code> of the <code>bdk_wallet</code> rust library.</p>"},{"location":"getting-started/getting-started/#install-rust","title":"Install Rust","text":"<p>See the Rust Getting Started page to install the Rust development tools.</p>"},{"location":"getting-started/getting-started/#using-bdk-in-a-rust-project","title":"Using BDK in a Rust project","text":"<p>Follow these steps to use BDK in your own rust project with the <code>electrum</code> blockchain client.</p> <ol> <li>Create a new Rust project:</li> </ol> <pre><code>cargo init my_bdk_app\ncd my_bdk_app\n</code></pre> <ol> <li>Add <code>bdk_wallet</code> to your <code>Cargo.toml</code> file. Find the latest <code>bdk_wallet</code> release on crates.io, for example:</li> </ol> <pre><code>cargo add bdk_wallet@1.0.0\n</code></pre> <ol> <li>Add other required dependencies:</li> </ol> <pre><code>cargo add bdk_electrum@0.20.1\n</code></pre> <p>Follow the Sync a Wallet with Electrum page for a simple example of how to create and sync a wallet.</p>"},{"location":"getting-started/migrating/","title":"Migrating from 0.X","text":"<p>So you're ready to migrate to BDK version 1.0, congratulations! This document contains some helpful tips that, with the help of some automation, should make the process as seamless as possible.</p> <p>The below steps are for migrating wallet details from the old <code>bdk</code> v0.30 to the new <code>bdk_wallet</code> v1.0. This procedure can be applied to wallets backed by a SQLite database.</p> <p>To migrate your wallet data to a new version of bdk, essentially all you need to do is grab the last known address index for each keychain from the old db, add them to the new db, and sync to refetch the rest of the data. Doing this means we don't need to perform a full scan because we already have the indexes (doing a full scan would check for used addresses based on the stop gap which is unnecessary).</p> <p>This migration is important because without that metadata the new wallet may end up reusing receive addresses, which should be avoided for privacy reasons, although it should not cause loss of funds.</p> <p>Tip</p> <p>NB: The migration process outlined below will not automatically restore the wallet's transaction data or local view of the blockchain. Thanks to the public ledger however, we can restore all the pertinent information for this wallet using one of the blockchain client libraries supported by BDK.</p>"},{"location":"getting-started/migrating/#overview","title":"Overview","text":"<ol> <li>Load an old database</li> <li>Get last revealed addresses</li> <li>Create new wallet</li> <li>Restore revealed addresses</li> <li>Write to new database</li> <li>Sync</li> </ol> examples/rust/migrate-version/src/main.rs<pre><code>fn main() -&gt; anyhow::Result&lt;()&gt; {\n    // Open old wallet\n    let db = SqliteDatabase::new(BDK_DB_PATH);\n    let old_wallet = bdk::Wallet::new(\n        EXTERNAL_DESCRIPTOR,\n        Some(INTERNAL_DESCRIPTOR),\n        bdk::bitcoin::Network::Testnet,\n        db,\n    )?;\n\n    // Get last revealed addresses for each keychain\n    let addr = old_wallet.get_address(AddressIndex::LastUnused)?;\n    println!(\"Last revealed external {} {}\", addr.index, addr.address);\n    let external_derivation_index = addr.index;\n    let last_revealed_external = addr.address.to_string();\n\n    let addr = old_wallet.get_internal_address(AddressIndex::LastUnused)?;\n    println!(\"Last revealed internal {} {}\", addr.index, addr.address);\n    let internal_derivation_index = addr.index;\n    let last_revealed_internal = addr.address.to_string();\n\n    // Create new wallet\n    let mut db = rusqlite::Connection::open(BDK_WALLET_DB_PATH)?;\n    let mut new_wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n        .network(NETWORK)\n        .create_wallet(&amp;mut db)\n        .context(\"failed to create wallet\")?;\n\n    // Retore revealed addresses\n    let _ = new_wallet.reveal_addresses_to(KeychainKind::External, external_derivation_index);\n    let _ = new_wallet.reveal_addresses_to(KeychainKind::Internal, internal_derivation_index);\n\n    // Persist new wallet\n    new_wallet.persist(&amp;mut db)?;\n\n    println!(\"\\n========== New database created. ==========\");\n\n    let addr = new_wallet\n        .list_unused_addresses(KeychainKind::External)\n        .last()\n        .unwrap();\n    assert_eq!(addr.to_string(), last_revealed_external);\n    println!(\"Last revealed external {} {}\", addr.index, addr.address);\n    let addr = new_wallet\n        .list_unused_addresses(KeychainKind::Internal)\n        .last()\n        .unwrap();\n    println!(\"Last revealed internal {} {}\", addr.index, addr.address);\n    assert_eq!(addr.to_string(), last_revealed_internal);\n\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/migrating/#walkthrough","title":"Walkthrough","text":"<p>In a new rust project add these dependencies to Cargo.toml</p> Cargo.toml<pre><code>[dependencies]\nanyhow = \"1\"\nbdk = { version = \"0.30\", features = [\"sqlite\"] }\nbdk_wallet = { version = \"1.0.0\", features = [\"rusqlite\"] }\n</code></pre> <p>Because there are two versions of bdk in the same project, we need to pay attention to how types are imported. To avoid name clashes or any sort of mismatch resolving types that appear similar, we use fully qualified syntax, for example <code>bdk::bitcoin::Network::Testnet</code>. You'll notice in some cases we can get around this annoyance by casting a value to another rust primitive or standard library type such as <code>String</code>.</p> examples/rust/migrate-version/src/main.rs<pre><code>use anyhow::Context;\n\nuse bdk::database::SqliteDatabase;\nuse bdk::wallet::AddressIndex;\n\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::rusqlite;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::Wallet;\n</code></pre> <p>Take a minute to define a few constants, for example the file path to the current database and the path to be used for the new database. The descriptors and network shown here are for illustration; you should substitute them with your own. Note that because we'll be creating a fresh database there should not already exist a persisted wallet at the new path.</p> examples/rust/migrate-version/src/main.rs<pre><code>const EXTERNAL_DESCRIPTOR: &amp;str = \"wpkh(tprv8ZgxMBicQKsPdy6LMhUtFHAgpocR8GC6QmwMSFpZs7h6Eziw3SpThFfczTDh5rW2krkqffa11UpX3XkeTTB2FvzZKWXqPY54Y6Rq4AQ5R8L/84'/1'/0'/0/*)\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"wpkh(tprv8ZgxMBicQKsPdy6LMhUtFHAgpocR8GC6QmwMSFpZs7h6Eziw3SpThFfczTDh5rW2krkqffa11UpX3XkeTTB2FvzZKWXqPY54Y6Rq4AQ5R8L/84'/1'/0'/1/*)\";\nconst NETWORK: Network = Network::Testnet;\n\n// path to old db\nconst BDK_DB_PATH: &amp;str = \"./.bdk-example.sqlite\";\n// path to new db\nconst BDK_WALLET_DB_PATH: &amp;str = \"./.bdk-wallet-example.sqlite\";\n</code></pre> <p>Now retrieve the last revealed addresses from the <code>old_wallet</code>.</p> examples/rust/migrate-version/src/main.rs<pre><code>// Open old wallet\nlet db = SqliteDatabase::new(BDK_DB_PATH);\nlet old_wallet = bdk::Wallet::new(\n    EXTERNAL_DESCRIPTOR,\n    Some(INTERNAL_DESCRIPTOR),\n    bdk::bitcoin::Network::Testnet,\n    db,\n)?;\n\n// Get last revealed addresses for each keychain\nlet addr = old_wallet.get_address(AddressIndex::LastUnused)?;\nprintln!(\"Last revealed external {} {}\", addr.index, addr.address);\nlet external_derivation_index = addr.index;\nlet last_revealed_external = addr.address.to_string();\n\nlet addr = old_wallet.get_internal_address(AddressIndex::LastUnused)?;\nprintln!(\"Last revealed internal {} {}\", addr.index, addr.address);\nlet internal_derivation_index = addr.index;\nlet last_revealed_internal = addr.address.to_string();\n</code></pre> <p>For the <code>new_wallet</code> we should be using the same descriptors and network as before. If the given descriptors contain secret keys, then the wallet will be able to sign transactions as well.</p> examples/rust/migrate-version/src/main.rs<pre><code>// Create new wallet\nlet mut db = rusqlite::Connection::open(BDK_WALLET_DB_PATH)?;\nlet mut new_wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n    .network(NETWORK)\n    .create_wallet(&amp;mut db)\n    .context(\"failed to create wallet\")?;\n\n// Retore revealed addresses\nlet _ = new_wallet.reveal_addresses_to(KeychainKind::External, external_derivation_index);\nlet _ = new_wallet.reveal_addresses_to(KeychainKind::Internal, internal_derivation_index);\n\n// Persist new wallet\nnew_wallet.persist(&amp;mut db)?;\n\nprintln!(\"\\n========== New database created. ==========\");\n\nlet addr = new_wallet\n    .list_unused_addresses(KeychainKind::External)\n    .last()\n    .unwrap();\nassert_eq!(addr.to_string(), last_revealed_external);\nprintln!(\"Last revealed external {} {}\", addr.index, addr.address);\nlet addr = new_wallet\n    .list_unused_addresses(KeychainKind::Internal)\n    .last()\n    .unwrap();\nprintln!(\"Last revealed internal {} {}\", addr.index, addr.address);\nassert_eq!(addr.to_string(), last_revealed_internal);\n</code></pre> <p>Now that we have a new database and have properly restored our addresses, you will want to sync with the blockchain to recover the wallet's transactions. Below is an example of doing a <code>sync</code> using <code>bdk_esplora</code> but the exact method of syncing will depend on your application. Remember we don't need to do a full scan here since we already have the indexes.</p> examples/rust/migrate-version/src/main.rs<pre><code>use bdk_esplora::{esplora_client, EsploraExt};\n\nlet client = esplora_client::Builder::new(ESPLORA_URL).build_blocking();\n\nlet request = wallet\n    .start_sync_with_revealed_spks()\n    .inspect(|item, prog| {\n        if let SyncItem::Spk(index, script) = item {\n            let address = Address::from_script(script, NETWORK).unwrap();\n            let progress = prog.consumed() as f32 / prog.total() as f32;\n            eprintln!(\"[ SYNCING {:.2}% ] {:?} {}\", 100.0 * progress, index, address);\n            std::io::stdout().flush().unwrap();\n        }\n    });\n\nlet update = client.sync(request, PARALLEL_REQUESTS)?;\n\nwallet.apply_update(update)?;\nwallet.persist(&amp;mut db)?;\n</code></pre> <p>Happy migrating and see you on v1.0!</p>"},{"location":"getting-started/more-bdk/","title":"More Places to Find BDK Content","text":"<p>Here are some other places you can find BDK-related content:</p>"},{"location":"getting-started/more-bdk/#youtube","title":"Youtube","text":"<ul> <li>Building on bitcoin with the Bitcoin Development Kit (BitDevsLA)</li> <li>The Bitcoin Developers channel has a series of videos on BDK.</li> <li>Building on BDK with Ben Carman, Alekos Filini &amp; Steve Myers</li> <li>Using the Bitcoin Development Kit and Wallet Descriptors for Taproot</li> <li>User Research on FOSS bitcoin project: Bitcoin Dev Kit</li> <li>Building wallets with Rust using Bitcoin (basic tutorial series)</li> <li>Magical Bitcoin (now BDK) presentation by Alekos Filini (BitDevsLA) </li> </ul>"},{"location":"getting-started/more-bdk/#podcasts","title":"Podcasts","text":"<ul> <li>Alekos and Daniela on the Chaincode Podcast</li> </ul>"},{"location":"getting-started/more-bdk/#awesome-list","title":"Awesome List","text":"<ul> <li>We maintain an Awesome List for BDK.</li> </ul>"},{"location":"getting-started/organization/","title":"Project Organization","text":"<p>Within the <code>bitcoindevkit</code> GitHub organization, the BDK team maintains a suite of Rust crates which provide both easy-to-use high level APIs and powerful lower level components to use when building more advanced bitcoin software.</p>"},{"location":"getting-started/organization/#source-code","title":"Source Code","text":"<p>The core project is split up into several crates in the <code>bdk/crates</code> directory:</p> <ul> <li><code>bdk_wallet</code>: Contains the central high level <code>Wallet</code> type    that is built from the low-level mechanisms provided by the other components.</li> <li><code>bdk_chain</code>: Tools for storing and indexing chain data.</li> <li><code>bdk_file_store</code>: A persistence backend for storing chain data in a single file.</li> <li><code>bdk_sqlite</code>: A simple SQLite relational database client for persisting bdk_chain data.</li> <li><code>bdk_esplora</code>: Extends the <code>esplora-client</code>    crate with methods to fetch chain data from an esplora HTTP server in the form that    <code>bdk_chain</code> and <code>Wallet</code> can consume.</li> <li><code>bdk_electrum</code>: Extends the <code>electrum-client</code>    crate with methods to fetch chain data from an electrum server in the form that    <code>bdk_chain</code> and <code>Wallet</code> can consume.</li> <li><code>bdk_bitcoind_rpc</code>: For extracting and emitting blockchain data from <code>bitcoind</code> RPC interface. </li> </ul>"},{"location":"getting-started/why-book/","title":"Who Is This Book For?","text":"<p>The purpose of this book is to give a strong overview of the Bitcoin Development Kit family of libraries and how they can be used together to build production-grade bitcoin applications. We aim to provide a good understanding of how to leverage our libraries together, expose the options available to developers in terms of blockchain clients and persistence layers, as well as ways they can go deeper into lower-level crates if their needs are not met by the high-level APIs exposed in the <code>bdk_wallet</code> library.</p> <p>Finally, the book is meant to get developers up to speed on general concepts pertaining to the BDK architecture as well as concrete examples of how to use our APIs in the different languages for which we provide language bindings libraries.</p> <p>What this book is not:</p> <ul> <li>API documentation, nor a comprehensive listing of all APIs available in BDK libraries. We maintain API docs on all our libraries for that purpose.</li> <li>A place to learn about core bitcoin concepts (PSBTs, UTXOs, Electrum protocol, BIPs, etc.). We provide links to great resources on these topics where appropriate.</li> <li>A comprehensive treatment of the tradeoff space developers face when building bitcoin applications (Esplora protocol vs compact block filters, onchain vs layer 2s, secure elements on mobile devices, etc.).</li> </ul>"},{"location":"release-guide/2.1/multipath/","title":"Wallet Support For Public Multipath Descriptors","text":"<p>Overview</p> <ul> <li>Lead Developer: @schjonhaug</li> <li>Ticket: #11</li> <li>Pull Request: #275</li> <li>Feature Type: Non-breaking</li> </ul>"},{"location":"release-guide/2.1/multipath/#overview","title":"Overview","text":"<ul> <li>We add a new API, <code>Wallet::create_multipath(descriptor)</code> following the same pattern as <code>create()</code> and <code>create_single()</code>.</li> <li>BIP 389 compliance with exactly 2-path validation (receive and change).</li> <li>The multipath descriptor must be a public descriptor.</li> </ul> Example<pre><code>let multipath_desc = \"wpkh([9a6a2580/84'/1'/0']tpubabcde.../\u20390;1\u203a/*)\";\nlet wallet = Wallet::create_multipath(multipath_desc)\n      .network(Network::Testnet)\n      .create_wallet_no_persist()?;\n\n// Automatically creates separate receive and change descriptors\nlet receive_address = wallet.peek_address(KeychainKind::External, 0);  // Uses path /0/*\nlet change_address = wallet.peek_address(KeychainKind::Internal, 0);   // Uses path /1/*\n</code></pre>"},{"location":"release-guide/2.1/multipath/#why-do-this","title":"Why Do This?","text":"<p>Multipath descriptors are fairly common nowadays, and there was a lot of demand for supporting a constructor on the wallet that would handle them gracefully.</p>"},{"location":"release-guide/2.1/multipath/#notes","title":"Notes","text":"<ul> <li>The constructor only allows exactly 2-path multipath descriptors to ensure proper receive/change separation.</li> </ul>"},{"location":"release-guide/2.1/notes/","title":"2.1 Release Notes","text":"<p>Overview</p> <ul> <li>Release Date: August 6, 2025</li> <li>Changelog: Link </li> </ul>"},{"location":"release-guide/2.1/notes/#notable-changes","title":"Notable Changes","text":"<ul> <li>The transaction builder adds 2 new methods: <code>TxBuilder::exclude_unconfirmed</code> and <code>TxBuilder::exclude_below_confirmations</code>. See details here.</li> <li>Wallets can now be created using public multipath descriptors. See details here.</li> </ul>"},{"location":"release-guide/2.1/txbuilder-exclude/","title":"Exclude Inputs Based On Maturity When Building Transactions","text":"<p>Overview</p> <ul> <li>Lead Developer: @evanlinjin</li> <li>Ticket: #143</li> <li>Pull Request: #258</li> <li>Feature Type: Non-breaking</li> </ul>"},{"location":"release-guide/2.1/txbuilder-exclude/#overview","title":"Overview","text":"<ul> <li>Two methods are added to the TxBuilder, allowing users to exclude inputs that are either (a) unconfirmed, or (b) below a certain confirmation threshold.</li> </ul> Example 1<pre><code>let mut builder = wallet.build_tx();\nbuilder\n    .fee_rate(FeeRate::ZERO)\n    .add_recipient(recipient_address.script_pubkey(), Amount::from_sat(50_000))\n    .exclude_unconfirmed();\nlet tx = builder.finish().unwrap();\n</code></pre> Example 2<pre><code>let mut builder = wallet.build_tx();\nbuilder\n    .fee_rate(FeeRate::ZERO)\n    .add_recipient(recipient_address.script_pubkey(), Amount::from_sat(50_000))\n    .exclude_below_confirmations(6);\nlet tx = builder.finish().unwrap();\n</code></pre>"},{"location":"release-guide/2.1/txbuilder-exclude/#why-do-this","title":"Why Do This?","text":"<p>These are convenience methods that fit a broad number of use cases. Previously, users had to do custom UTXO selection if they needed to ensure they used inputs that were confirmed onchain, or had a certain number of confirmations. This allows users to keep the BDK coins selection algos working their magic while also refraining from picking inputs that are not yet confirmed or within a specific confirmation threshold.</p> <p></p>"},{"location":"release-guide/2.2/notes/","title":"2.2 Release Notes","text":"<p>Overview</p> <ul> <li>Release Date: October 1, 2025</li> <li>Changelog: Link </li> </ul>"},{"location":"release-guide/2.2/notes/#notable-changes","title":"Notable Changes","text":"<ul> <li>A new method, <code>Wallet::apply_update_events</code>, returns a list of events that were contained in the update when applied on the wallet. Learn more about this feature here.</li> <li>The signer module has been deprecated and is planned to be removed in a future release.</li> </ul>"},{"location":"release-guide/2.2/wallet-events/","title":"Applying Wallet Updates Returns A List of Events","text":"<p>Overview</p> <ul> <li>Lead Developer: @notmandatory</li> <li>Ticket: #6</li> <li>Pull Request: #310</li> <li>ADR: Link</li> <li>Feature Type: Non-breaking</li> </ul>"},{"location":"release-guide/2.2/wallet-events/#overview","title":"Overview","text":"<p>Applying updates to the <code>Wallet</code> would now return a list of events that were contained in this update on the wallet.</p> <pre><code>let events: Vec&lt;WalletEvent&gt; = wallet.apply_update_events(update);\n</code></pre> <p>The WalletEvent is an enum with variants that signal things like a change in the blockchain tip, a new transaction confirmed, a transaction has been RBF'd, etc.</p> <pre><code>enum WalletEvent {\n    ChainTipChanged {\n        old_tip: BlockId,\n        new_tip: BlockId,\n    },\n    TxConfirmed {\n        txid: Txid,\n        tx: Arc&lt;Transaction&gt;,\n        block_time: ConfirmationBlockTime,\n    },\n    /// ...\n}\n</code></pre>"},{"location":"release-guide/2.2/wallet-events/#why-do-this","title":"Why Do This?","text":"<p>When syncing a <code>Wallet</code> with new blockchain data using Wallet::apply_update, it does not return any value on success, and only a <code>CannotConnectError</code> if it fails. </p> <p>Users have asked for a concise list of events that reflect if or how new blockchain data has changed the blockchain tip and the status of transactions relevant to the wallet's balance. This information is useful for downstream libraries who rely on these events for triggering their own work, as well as for applications who want to notify users of wallet changes after syncing.</p>"},{"location":"release-guide/2.2/wallet-events/#applying-an-update-to-wallet-now-returns-vecwalletevent","title":"Applying An Update to Wallet Now Returns <code>Vec&lt;WalletEvent&gt;</code>","text":"<p>This new feature adds a <code>WalletEvent</code> enum of user-facing events that are generated when a sync update is applied to a wallet using the existing <code>Wallet::apply_update</code> function. The <code>WalletEvent</code> enum includes an event for changes in blockchain tip and events for changes to the status of transactions that are relevant to the wallet, including:</p> <ol> <li>Newly seen in the mempool</li> <li>Replaced in the mempool </li> <li>Dropped from the mempool</li> <li>Confirmed in a block</li> <li>Confirmed in a new block due to a reorg</li> <li>Unconfirmed due to a reorg</li> </ol> <p>Chain tip change events are generated by comparing the wallet's chain tip before and after applying an update. Wallet transaction events are generated by comparing a snapshot of canonical transactions.</p> <p>As long as updates to the wallet are not persisted until after all events are processed by the caller, then if the app crashes for some reason and the wallet is re-sync'd a new update will re-return the same events.</p> <p>The <code>WalletEvent</code> enum is non-exhaustive.</p> <p></p>"}]}